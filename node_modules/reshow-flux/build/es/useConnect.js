import _slicedToArray from "reshow-runtime/es/helpers/slicedToArray";
import { useState, useEffect, useDebugValue } from "react";
import { useMounted } from "reshow-hooks";
import { T_TRUE } from "reshow-constant";
import getStore from "./getStore";

var handleShouldComponentUpdate = function handleShouldComponentUpdate(_ref) {
  var options = _ref.options,
      shouldComponentUpdate = _ref.shouldComponentUpdate,
      calculateState = _ref.calculateState,
      prev = _ref.prev,
      props = _ref.props;
  var nextState = calculateState(prev.state, options);
  var bUpdate = !shouldComponentUpdate || shouldComponentUpdate({
    prev: prev,
    nextProps: props,
    nextState: nextState
  });

  if (!bUpdate || props === prev.props && nextState === prev.state) {
    prev.__init__ = T_TRUE;
    return prev;
  } else {
    return {
      props: props,
      __init__: T_TRUE,
      state: nextState
    };
  }
};

var useConnect = function useConnect() {
  var inputOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (props) {
    var options = getStore({
      options: inputOptions,
      props: props
    });
    var calculateState = options.calculateState,
        shouldComponentUpdate = options.shouldComponentUpdate,
        _options$displayName = options.displayName,
        displayName = _options$displayName === void 0 ? "useConnect" : _options$displayName;
    useDebugValue(displayName);

    var _useState = useState(function () {
      return {
        props: props,
        state: calculateState({}, options)
      };
    }),
        _useState2 = _slicedToArray(_useState, 2),
        data = _useState2[0],
        setData = _useState2[1];

    var isMount = useMounted();
    useEffect(function () {
      var handleChange = function handleChange() {
        var storeState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : options.storeState;

        if (T_TRUE === isMount()) {
          options.storeState = storeState;
          setData(function (prev) {
            return handleShouldComponentUpdate({
              options: options,
              shouldComponentUpdate: shouldComponentUpdate,
              calculateState: calculateState,
              prev: prev,
              props: props
            });
          });
        }
      };

      if (!data.__init__ || data.props !== props) {
        handleChange();
      }

      options.store.addListener(handleChange);
      return function () {
        options.store.removeListener(handleChange);
      };
    }, props.changeable ? [props] : []);
    return data.state || {};
  };
};

export default useConnect;