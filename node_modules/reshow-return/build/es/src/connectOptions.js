import _toConsumableArray from "reshow-runtime/es/helpers/toConsumableArray";
import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import get from "get-object-value";
import callfunc from "call-func";
import { toJS } from "reshow-flux";
import { IS_ARRAY, KEYS } from "reshow-constant";

var getImmutable = function getImmutable(immutable) {
  return function (data) {
    return !immutable ? toJS(data) : data;
  };
};

var getMapIn = function getMapIn(map, path) {
  return map && map.getIn ? map.getIn(path) : undefined;
};

var reset = function reset(props, more) {
  var nextProps = _objectSpread({}, props);

  var cleanKeys = ["busting", "changeable", "immutable", "initStates", "pathStates", "store", "storeLocator"].concat(_toConsumableArray(more || []));
  var i = cleanKeys.length;

  while (i--) {
    delete nextProps[cleanKeys[i]];
  }

  return nextProps;
};

var stateValueGetter = function stateValueGetter(state) {
  return function (k) {
    return state.get ? state.get(k) : get(state, [k]);
  };
};

var calculateState = function calculateState(prevState, options) {
  /**
   * Why not support multi stores?
   * Because multi stores need handle complex data merge.
   * If that case need create custom calculateState functoin.
   */
  var initStates = options.initStates,
      pathStates = options.pathStates,
      optImmutable = options.immutable,
      storeState = options.storeState;
  var getStateValue = stateValueGetter(storeState);
  var immutable = optImmutable || getStateValue("immutable");
  var results = {};

  if (immutable) {
    results.immutable = immutable;
  }

  var toImmutable = getImmutable(immutable);

  if (IS_ARRAY(initStates)) {
    initStates.forEach(function (key) {
      var data = getStateValue(key);
      results[key] = toImmutable(data);
    });
  } else if (initStates) {
    KEYS(initStates).forEach(function (key) {
      var data = getStateValue(key);
      var newKey = null != initStates[key] ? initStates[key] : key;
      results[newKey] = toImmutable(data);
    });
  }

  KEYS(pathStates || {}).forEach(function (key) {
    var thisPath = pathStates[key];
    results[key] = immutable ? getMapIn(results[thisPath[0]], thisPath.slice(1)) : get(results, thisPath);
  });
  var resultKeys = KEYS(results);
  var bSame = true;
  var i = resultKeys.length;

  while (i--) {
    var key = resultKeys[i];

    if (results[key] !== prevState[key]) {
      bSame = false;
      break;
    }
  }

  return bSame ? prevState : results;
};

var connectOptions = {
  calculateState: calculateState,
  reset: reset
};
export default connectOptions;