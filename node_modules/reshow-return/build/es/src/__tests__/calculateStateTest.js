import _slicedToArray from "reshow-runtime/es/helpers/slicedToArray";
import { expect } from "chai";
import { ImmutableStore, Map, mergeMap } from "reshow-flux";
import options from "../connectOptions";
var calculateState = options.calculateState;
describe("Test calculateState", function () {
  var pageStore;
  beforeEach(function () {
    var _ImmutableStore = ImmutableStore(function (state, action) {
      switch (action.type) {
        case "config/reset":
          return mergeMap(state.clear(), action.params);

        default:
          if (Object.keys(action)) {
            return mergeMap(state, action);
          } else {
            return state;
          }

      }
    }),
        _ImmutableStore2 = _slicedToArray(_ImmutableStore, 2),
        store = _ImmutableStore2[0],
        dispatch = _ImmutableStore2[1];

    dispatch("config/reset", {
      foo: {
        bar: {
          foo1: "bar1"
        }
      }
    });
    pageStore = store;
  });
  it("path data with immutable", function () {
    var actual = calculateState({}, {
      initStates: ["foo"],
      pathStates: {
        bar: ["foo", "bar"]
      },
      immutable: true,
      storeState: pageStore.getState()
    });
    expect(actual.bar instanceof Map).to.be["true"];
  });
  it("path data with immutable not exits", function () {
    var acture = calculateState({}, {
      pathStates: {
        bar: ["foo", "bar"]
      },
      immutable: true,
      storeState: pageStore.getState()
    });
    expect(acture.bar).to.be.undefined;
  });
  it("path data with non immutable", function () {
    var acture = calculateState({}, {
      initStates: ["foo"],
      pathStates: {
        bar: ["foo", "bar"]
      },
      storeState: pageStore.getState()
    });
    expect(acture.bar).to.deep.equal({
      foo1: "bar1"
    });
  });
});