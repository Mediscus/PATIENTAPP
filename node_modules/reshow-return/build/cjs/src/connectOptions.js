"use strict";

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("reshow-runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("reshow-runtime/helpers/objectSpread2"));

var _getObjectValue = _interopRequireDefault(require("get-object-value"));

var _callFunc = _interopRequireDefault(require("call-func"));

var _reshowFlux = require("reshow-flux");

var _reshowConstant = require("reshow-constant");

var getImmutable = function getImmutable(immutable) {
  return function (data) {
    return !immutable ? (0, _reshowFlux.toJS)(data) : data;
  };
};

var getMapIn = function getMapIn(map, path) {
  return map && map.getIn ? map.getIn(path) : undefined;
};

var reset = function reset(props, more) {
  var nextProps = (0, _objectSpread2["default"])({}, props);
  var cleanKeys = ["busting", "changeable", "immutable", "initStates", "pathStates", "store", "storeLocator"].concat((0, _toConsumableArray2["default"])(more || []));
  var i = cleanKeys.length;

  while (i--) {
    delete nextProps[cleanKeys[i]];
  }

  return nextProps;
};

var stateValueGetter = function stateValueGetter(state) {
  return function (k) {
    return state.get ? state.get(k) : (0, _getObjectValue["default"])(state, [k]);
  };
};

var calculateState = function calculateState(prevState, options) {
  /**
   * Why not support multi stores?
   * Because multi stores need handle complex data merge.
   * If that case need create custom calculateState functoin.
   */
  var initStates = options.initStates,
      pathStates = options.pathStates,
      optImmutable = options.immutable,
      storeState = options.storeState;
  var getStateValue = stateValueGetter(storeState);
  var immutable = optImmutable || getStateValue("immutable");
  var results = {};

  if (immutable) {
    results.immutable = immutable;
  }

  var toImmutable = getImmutable(immutable);

  if ((0, _reshowConstant.IS_ARRAY)(initStates)) {
    initStates.forEach(function (key) {
      var data = getStateValue(key);
      results[key] = toImmutable(data);
    });
  } else if (initStates) {
    (0, _reshowConstant.KEYS)(initStates).forEach(function (key) {
      var data = getStateValue(key);
      var newKey = null != initStates[key] ? initStates[key] : key;
      results[newKey] = toImmutable(data);
    });
  }

  (0, _reshowConstant.KEYS)(pathStates || {}).forEach(function (key) {
    var thisPath = pathStates[key];
    results[key] = immutable ? getMapIn(results[thisPath[0]], thisPath.slice(1)) : (0, _getObjectValue["default"])(results, thisPath);
  });
  var resultKeys = (0, _reshowConstant.KEYS)(results);
  var bSame = true;
  var i = resultKeys.length;

  while (i--) {
    var key = resultKeys[i];

    if (results[key] !== prevState[key]) {
      bSame = false;
      break;
    }
  }

  return bSame ? prevState : results;
};

var connectOptions = {
  calculateState: calculateState,
  reset: reset
};
var _default = connectOptions;
exports["default"] = _default;
module.exports = exports.default;