{"version":3,"file":"react-charts.cjs.production.min.js","sources":["../src/hooks/useGetLatest.ts","../src/hooks/useIsomorphicLayoutEffect.ts","../src/hooks/useRect.ts","../src/utils/Utils.ts","../src/utils/chartContext.tsx","../src/utils/curveMonotone.ts","../src/seriesTypes/Area.tsx","../src/seriesTypes/Bar.tsx","../src/seriesTypes/Line.tsx","../src/utils/buildAxis.linear.ts","../src/components/AxisLinear.useMeasure.ts","../src/components/AxisLinear.tsx","../src/hooks/useLatestWhen.ts","../src/hooks/usePortalElement.ts","../src/components/Cursors.tsx","../src/hooks/useAnchor.tsx","../src/hooks/usePrevious.ts","../src/components/TooltipRenderer.tsx","../src/components/Tooltip.tsx","../src/components/Voronoi.tsx","../src/components/Chart.tsx"],"sourcesContent":["import React from 'react'\n\nexport default function useGetLatest<T>(obj: T) {\n  const ref = React.useRef<T>(obj)\n  const getterRef = React.useRef<() => T>()\n\n  ref.current = obj\n  if (!getterRef.current) {\n    getterRef.current = () => ref.current\n  }\n\n  return getterRef.current\n}\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport type HasBoundingClientRect = {\n  getBoundingClientRect: () => DOMRect\n}\n\nexport default function useRect(\n  node: HasBoundingClientRect | null | undefined,\n  options?: {\n    enabled?: boolean\n    initialWidth?: number\n    initialHeight?: number\n  }\n) {\n  const enabled = options?.enabled ?? true\n\n  const [element, setElement] = React.useState(node)\n\n  let [rect, setRect] = React.useState<DOMRect>({\n    width: options?.initialWidth ?? 0,\n    height: options?.initialHeight ?? 0,\n  } as DOMRect)\n\n  useIsomorphicLayoutEffect(() => {\n    if (node !== element) {\n      setElement(node)\n    }\n  })\n\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      setRect(element.getBoundingClientRect())\n    }\n  }, [element])\n\n  // const isScrolling = useIsScrolling(200)\n\n  React.useEffect(() => {\n    if (!element || !enabled) {\n      return\n    }\n\n    const observer = observeRect(element as Element, setRect)\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element, enabled])\n\n  // const resolvedRect = React.useMemo(() => {\n  //   if (!element || !(element as Element).tagName) {\n  //     return rect\n  //   }\n\n  //   const styles = window.getComputedStyle(element as Element)\n\n  //   return {\n  //     x: rect.x,\n  //     y: rect.y,\n  //     width:\n  //       rect.width -\n  //       parseInt(styles.borderLeftWidth) -\n  //       parseInt(styles.borderRightWidth),\n  //     height:\n  //       rect.height -\n  //       parseInt(styles.borderTopWidth) -\n  //       parseInt(styles.borderBottomWidth),\n  //     top: rect.top,\n  //     right: rect.right,\n  //     bottom: rect.bottom,\n  //     left: rect.left,\n  //   }\n  // }, [element, rect])\n\n  return rect\n}\n","import {\n  Axis,\n  Datum,\n  DatumFocusStatus,\n  DatumStyles,\n  Series,\n  SeriesFocusStatus,\n  SeriesStyles,\n} from '../types'\n\nexport function getSeriesStatus<TDatum>(\n  series: Series<TDatum>,\n  focusedDatum: Datum<TDatum> | null\n): SeriesFocusStatus {\n  if (focusedDatum?.seriesId === series.id) {\n    return 'focused'\n  }\n\n  return 'none'\n}\n\nexport function getDatumStatus<TDatum>(\n  datum: Datum<TDatum>,\n  focusedDatum: Datum<TDatum> | null\n): DatumFocusStatus {\n  if (datum === focusedDatum) {\n    return 'focused'\n  }\n\n  if (\n    datum.group?.some(groupDatum => {\n      groupDatum.seriesId === focusedDatum?.seriesId &&\n        groupDatum.index === focusedDatum?.index\n    })\n  ) {\n    return 'groupFocused'\n  }\n\n  return 'none'\n}\n\nfunction normalizeColor(\n  style: SeriesStyles | DatumStyles,\n  defaults: SeriesStyles | DatumStyles\n): SeriesStyles | DatumStyles {\n  return {\n    ...style,\n    stroke: style.stroke || style.color || defaults.stroke || defaults.color,\n    fill: style.fill || style.color || defaults.fill || defaults.color,\n  }\n}\n\nconst elementTypes = ['area', 'line', 'rectangle', 'circle'] as const\n\nexport function materializeStyles(\n  style: SeriesStyles | DatumStyles = {},\n  defaults: SeriesStyles | DatumStyles = {}\n) {\n  style = normalizeColor(style, defaults)\n  for (let i = 0; i < elementTypes.length; i++) {\n    const type = elementTypes[i]\n    if (style[type] && defaults[type]) {\n      style[type] = materializeStyles(style[type], defaults)\n    }\n  }\n  return style\n}\n\nexport function isValidPoint(d: any) {\n  if (d === null) {\n    return false\n  }\n  if (typeof d === 'undefined') {\n    return false\n  }\n  if (typeof d === 'string' && d === 'null') {\n    return false\n  }\n  return true\n}\n\nexport function translateX(x: number) {\n  return `translate3d(${Math.round(x)}px, 0, 0)`\n}\n\nexport function translateY(y: number) {\n  return `translate3d(0, ${Math.round(y)}px, 0)`\n}\n\nexport function translate(x: number, y: number) {\n  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`\n}\n\nexport function getSecondaries<TDatum>(\n  datum: Datum<TDatum>,\n  secondaryAxis: Axis<TDatum>\n): [number, number] {\n  if (secondaryAxis.stacked) {\n    return [\n      secondaryAxis.scale(datum.stackData?.[0] ?? NaN) ?? NaN,\n      secondaryAxis.scale(datum.stackData?.[1] ?? NaN) ?? NaN,\n    ]\n  }\n\n  return [\n    secondaryAxis.scale(0) ?? NaN,\n    secondaryAxis.scale(secondaryAxis.getValue(datum.originalDatum)) ?? NaN,\n  ]\n}\n\nexport function getPrimary<TDatum>(\n  datum: Datum<TDatum>,\n  primaryAxis: Axis<TDatum>\n): number {\n  let primary: number\n\n  if (primaryAxis.stacked) {\n    primary =\n      primaryAxis.scale(datum.stackData?.[primaryAxis.invert ? 1 : 0] ?? NaN) ??\n      NaN\n  } else {\n    primary =\n      primaryAxis.scale(primaryAxis.getValue(datum.originalDatum)) ?? NaN\n  }\n\n  if (primaryAxis.axisFamily !== 'band') {\n    primary = primary - getPrimaryLength(datum, primaryAxis) / 2\n  }\n\n  return primary\n}\n\nexport function getPrimaryLength<TDatum>(\n  _datum: Datum<TDatum>,\n  primaryAxis: Axis<TDatum>\n) {\n  if (primaryAxis.axisFamily === 'band') {\n    return Math.min(\n      Math.max(\n        primaryAxis.scale.bandwidth(),\n        primaryAxis.minBandSize ?? 99999999\n      ),\n      primaryAxis.maxBandSize ?? 1\n    )\n  }\n\n  return Math.max(primaryAxis.bandScale.bandwidth(), 1)\n}\n\nexport function getSecondaryLength<TDatum>(\n  datum: Datum<TDatum>,\n  secondaryAxis: Axis<TDatum>\n): number {\n  const secondary = getSecondaries(datum, secondaryAxis).sort()\n  return Math.abs(secondary[1] - secondary[0])\n}\n\nexport function getX<TDatum>(\n  datum: Datum<TDatum>,\n  primaryAxis: Axis<TDatum>,\n  secondaryAxis: Axis<TDatum>\n): number {\n  return primaryAxis.isVertical\n    ? getSecondaries(datum, secondaryAxis)[secondaryAxis.invert ? 1 : 0]\n    : getPrimary(datum, primaryAxis)\n}\n\nexport function getY<TDatum>(\n  datum: Datum<TDatum>,\n  primaryAxis: Axis<TDatum>,\n  secondaryAxis: Axis<TDatum>\n): number {\n  return primaryAxis.isVertical\n    ? getPrimary(datum, primaryAxis)\n    : getSecondaries(datum, secondaryAxis)[secondaryAxis.invert ? 1 : 0] -\n        getSecondaryLength(datum, secondaryAxis)\n}\n\nexport function getWidth<TDatum>(\n  datum: Datum<TDatum>,\n  primaryAxis: Axis<TDatum>,\n  secondaryAxis: Axis<TDatum>\n): number {\n  return primaryAxis.isVertical\n    ? getSecondaryLength(datum, secondaryAxis)\n    : getPrimaryLength(datum, primaryAxis)\n}\n\nexport function getHeight<TDatum>(\n  datum: Datum<TDatum>,\n  primaryAxis: Axis<TDatum>,\n  secondaryAxis: Axis<TDatum>\n): number {\n  return primaryAxis.isVertical\n    ? getPrimaryLength(datum, primaryAxis)\n    : getSecondaryLength(datum, secondaryAxis)\n}\n\nexport function getTickPx<TDatum>(scale: Axis<TDatum>['scale'], value: any) {\n  let px = scale(value) ?? NaN\n\n  // @ts-ignore\n  if (scale.bandwidth) {\n    // @ts-ignore\n    return px + scale.bandwidth() / 2\n  }\n\n  return px\n}\n","import * as React from 'react'\n\nimport { ChartContextValue } from '../types'\n\nconst chartContext = React.createContext<any>(null!)\n\nexport function ChartContextProvider<TDatum>({\n  value,\n  children,\n}: {\n  value: () => ChartContextValue<TDatum>\n  children: React.ReactNode\n}) {\n  return <chartContext.Provider value={value} children={children} />\n}\n\nexport default function useChartContext<TDatum>() {\n  return React.useContext(chartContext)() as ChartContextValue<TDatum>\n}\n","// @ts-nocheck\nimport { CurveFactory } from 'd3-shape'\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n    h1 = x2 - that._x1,\n    s0 = (that._y1 - that._y0) / (h0 || (h1 < 0 && -0)),\n    s1 = (y2 - that._y1) / (h1 || (h0 < 0 && -0)),\n    p = (s0 * h1 + s1 * h0) / (h0 + h1)\n  return (\n    (sign(s0) + sign(s1)) *\n      Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0\n  )\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0\n  return h ? ((3 * (that._y1 - that._y0)) / h - t) / 2 : t\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic BÃ©zier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point(that, t0, t1) {\n  var x0 = that._x0,\n    y0 = that._y0,\n    x1 = that._x1,\n    y1 = that._y1,\n    dx = (x1 - x0) / 3\n  that._context.bezierCurveTo(\n    x0 + dx,\n    y0 + dx * t0,\n    x1 - dx,\n    y1 - dx * t1,\n    x1,\n    y1\n  )\n}\n\nfunction MonotoneX(context) {\n  this._context = context\n}\n\nMonotoneX.prototype = {\n  areaStart: function () {\n    this._line = 0\n  },\n  areaEnd: function () {\n    this._line = NaN\n  },\n  lineStart: function () {\n    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN\n    this._point = 0\n  },\n  lineEnd: function () {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x1, this._y1)\n        break\n      case 3:\n        point(this, this._t0, slope2(this, this._t0))\n        break\n    }\n    if (this._line || (this._line !== 0 && this._point === 1))\n      this._context.closePath()\n    this._line = 1 - this._line\n  },\n  point: function (x, y) {\n    var t1 = NaN\n\n    ;(x = +x), (y = +y)\n    if (x === this._x1 && y === this._y1) return // Ignore coincident points.\n    switch (this._point) {\n      case 0:\n        this._point = 1\n        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y)\n        break\n      case 1:\n        this._point = 2\n        break\n      case 2:\n        this._point = 3\n        point(this, slope2(this, (t1 = slope3(this, x, y))), t1)\n        break\n      default:\n        point(this, this._t0, (t1 = slope3(this, x, y)))\n        break\n    }\n\n    ;(this._x0 = this._x1), (this._x1 = x)\n    ;(this._y0 = this._y1), (this._y1 = y)\n    this._t0 = t1\n  },\n}\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context)\n}\n\n;(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (\n  x,\n  y\n) {\n  MonotoneX.prototype.point.call(this, y, x)\n}\n\nfunction ReflectContext(context) {\n  this._context = context\n}\n\nReflectContext.prototype = {\n  moveTo: function (x, y) {\n    this._context.moveTo(y, x)\n  },\n  closePath: function () {\n    this._context.closePath()\n  },\n  lineTo: function (x, y) {\n    this._context.lineTo(y, x)\n  },\n  bezierCurveTo: function (x1, y1, x2, y2, x, y) {\n    this._context.bezierCurveTo(y1, x1, y2, x2, y, x)\n  },\n}\n\nexport const monotoneX: CurveFactory = context => new MonotoneX(context)\n\nexport const monotoneY: CurveFactory = context => new MonotoneY(context)\n","import { area, line } from 'd3-shape'\nimport React from 'react'\n\nimport { Axis, Series, Datum } from '../types'\nimport { translate } from '../utils/Utils'\nimport useChartContext from '../utils/chartContext'\n//\nimport { monotoneX } from '../utils/curveMonotone'\n\nexport default function AreaComponent<TDatum>({\n  primaryAxis,\n  secondaryAxis,\n  series: allSeries,\n}: {\n  primaryAxis: Axis<TDatum>\n  secondaryAxis: Axis<TDatum>\n  series: Series<TDatum>[]\n}) {\n  const {\n    getSeriesStatusStyle,\n    getDatumStatusStyle,\n    useFocusedDatumAtom,\n    gridDimensions,\n  } = useChartContext<TDatum>()\n\n  const curve = secondaryAxis.curve ?? monotoneX\n\n  const [focusedDatum] = useFocusedDatumAtom()\n\n  const xAxis = primaryAxis.isVertical ? secondaryAxis : primaryAxis\n  const yAxis = !primaryAxis.isVertical ? secondaryAxis : primaryAxis\n\n  const getX = (datum: Datum<TDatum>) =>\n    xAxis.scale(\n      xAxis.stacked ? datum.stackData?.[1] : xAxis.getValue(datum.originalDatum)\n    )\n\n  const getY = (datum: Datum<TDatum>, isEnd: 0 | 1) =>\n    yAxis.scale(\n      yAxis.stacked\n        ? datum.stackData?.[isEnd]\n        : yAxis.getValue(datum.originalDatum)\n    )\n\n  return (\n    <g\n      style={{\n        transform: translate(gridDimensions.gridX, gridDimensions.gridY),\n      }}\n    >\n      {allSeries.map((series, i) => {\n        const style = getSeriesStatusStyle(series, focusedDatum)\n\n        const lineStyle = {\n          strokeWidth: 2,\n          ...style,\n          ...style.line,\n          fill: 'none',\n        }\n\n        const areaStyle = {\n          strokeWidth: 2,\n          opacity: 0.5,\n          ...style,\n          ...style.area,\n        }\n\n        const areaPath =\n          area<Datum<TDatum>>(\n            datum => getX(datum) ?? NaN,\n            datum => getY(datum, 0) ?? NaN,\n            datum => getY(datum, 1) ?? NaN\n          ).curve(curve)(series.datums) ?? undefined\n\n        const linePath =\n          line<Datum<TDatum>>(\n            datum => getX(datum) ?? NaN,\n            datum => getY(datum, 1) ?? NaN\n          ).curve(curve)(series.datums) ?? undefined\n\n        return (\n          <g key={`lines-${i}`}>\n            <path d={areaPath} style={areaStyle} />\n            <path d={linePath} style={lineStyle} />\n            {series.datums.map((datum, i) => {\n              const dataStyle = getDatumStatusStyle(datum, focusedDatum)\n\n              return (\n                <circle\n                  key={i}\n                  ref={el => {\n                    datum.element = el\n                  }}\n                  r={2}\n                  cx={getX(datum)}\n                  cy={getY(datum, 1) ?? NaN}\n                  stroke=\"rgba(33,33,33,0.5)\"\n                  style={{\n                    // @ts-ignore\n                    r: 2,\n                    ...style,\n                    ...style.circle,\n                    ...dataStyle,\n                    ...dataStyle.circle,\n                    ...(!(secondaryAxis.showDatumElements ?? true)\n                      ? {\n                          opacity: 0,\n                        }\n                      : {}),\n                  }}\n                />\n              )\n            })}\n          </g>\n        )\n      })}\n    </g>\n  )\n}\n","import React from 'react'\n\nimport { Axis, Series } from '../types'\nimport { getHeight, getWidth, getX, getY, translate } from '../utils/Utils'\nimport useChartContext from '../utils/chartContext'\n\n//\n\nexport default function BarComponent<TDatum>({\n  primaryAxis,\n  secondaryAxis,\n  series: allSeries,\n}: {\n  primaryAxis: Axis<TDatum>\n  secondaryAxis: Axis<TDatum>\n  series: Series<TDatum>[]\n}) {\n  const {\n    getSeriesStatusStyle,\n    getDatumStatusStyle,\n    useFocusedDatumAtom,\n    gridDimensions,\n  } = useChartContext<TDatum>()\n\n  const [focusedDatum] = useFocusedDatumAtom()\n\n  return (\n    <g\n      style={{\n        transform: translate(gridDimensions.gridX, gridDimensions.gridY),\n      }}\n    >\n      {allSeries.map((series, i) => {\n        const style = getSeriesStatusStyle(series, focusedDatum)\n\n        return (\n          <g key={`lines-${i}`}>\n            {series.datums.map((datum, i) => {\n              const dataStyle = getDatumStatusStyle(datum, focusedDatum)\n\n              return (\n                <rect\n                  ref={el => {\n                    datum.element = el\n                  }}\n                  key={i}\n                  x={getX(datum, primaryAxis, secondaryAxis) ?? NaN}\n                  y={getY(datum, primaryAxis, secondaryAxis) ?? NaN}\n                  width={getWidth(datum, primaryAxis, secondaryAxis) ?? NaN}\n                  height={getHeight(datum, primaryAxis, secondaryAxis) ?? NaN}\n                  style={{\n                    strokeWidth: 0,\n                    ...style,\n                    ...style.rectangle,\n                    ...dataStyle,\n                    ...dataStyle.rectangle,\n                  }}\n                />\n              )\n            })}\n          </g>\n        )\n      })}\n    </g>\n  )\n}\n","import { line } from 'd3-shape'\nimport React from 'react'\n\nimport { Axis, Series, Datum } from '../types'\nimport { translate } from '../utils/Utils'\nimport useChartContext from '../utils/chartContext'\n//\nimport { monotoneX } from '../utils/curveMonotone'\n\nconst pathDefaultStyle = {\n  strokeWidth: 2,\n}\n\nexport default function Line<TDatum>({\n  primaryAxis,\n  secondaryAxis,\n  series: allSeries,\n}: {\n  primaryAxis: Axis<TDatum>\n  secondaryAxis: Axis<TDatum>\n  series: Series<TDatum>[]\n}) {\n  const {\n    getSeriesStatusStyle,\n    getDatumStatusStyle,\n    useFocusedDatumAtom,\n    gridDimensions,\n  } = useChartContext<TDatum>()\n\n  const curve = secondaryAxis.curve ?? monotoneX\n\n  const [focusedDatum] = useFocusedDatumAtom()\n\n  const xAxis = primaryAxis.isVertical ? secondaryAxis : primaryAxis\n  const yAxis = !primaryAxis.isVertical ? secondaryAxis : primaryAxis\n\n  const getX = (datum: Datum<TDatum>) =>\n    xAxis.scale(\n      xAxis.stacked ? datum.stackData?.[1] : xAxis.getValue(datum.originalDatum)\n    )\n\n  const getY = (datum: Datum<TDatum>) =>\n    yAxis.scale(\n      yAxis.stacked ? datum.stackData?.[1] : yAxis.getValue(datum.originalDatum)\n    )\n\n  return (\n    <g\n      style={{\n        transform: translate(gridDimensions.gridX, gridDimensions.gridY),\n      }}\n    >\n      {allSeries.map((series, i) => {\n        const style = getSeriesStatusStyle(series, focusedDatum)\n\n        const lineStyle = {\n          ...pathDefaultStyle,\n          ...style,\n          ...style.line,\n          fill: 'none',\n        }\n\n        const linePath =\n          line<Datum<TDatum>>(\n            datum => getX(datum) ?? NaN,\n            datum => getY(datum) ?? NaN\n          ).curve(curve)(series.datums) ?? undefined\n\n        return (\n          <g key={`lines-${i}`}>\n            {series.datums.map((datum, i) => {\n              const dataStyle = getDatumStatusStyle(datum, focusedDatum)\n\n              return (\n                <circle\n                  key={i}\n                  ref={el => {\n                    datum.element = el\n                  }}\n                  r={2}\n                  cx={getX(datum)}\n                  cy={getY(datum)}\n                  stroke=\"rgba(33,33,33,0.5)\"\n                  fill=\"transparent\"\n                  style={{\n                    // @ts-ignore\n                    r: 2,\n                    ...style,\n                    ...style.circle,\n                    ...dataStyle,\n                    ...dataStyle.circle,\n                    ...(!(secondaryAxis.showDatumElements ?? true)\n                      ? {\n                          opacity: 0,\n                        }\n                      : {}),\n                  }}\n                />\n              )\n            })}\n            <path d={linePath} style={lineStyle} />\n          </g>\n        )\n      })}\n    </g>\n  )\n}\n","import { extent, range as d3Range } from 'd3-array'\nimport {\n  scaleLinear,\n  scaleLog,\n  scaleTime,\n  scaleUtc,\n  scaleBand,\n  ScaleTime,\n  ScaleLinear,\n} from 'd3-scale'\n\nimport {\n  Axis,\n  AxisBand,\n  AxisBandOptions,\n  AxisLinear,\n  AxisLinearOptions,\n  AxisOptions,\n  AxisTime,\n  AxisTimeOptions,\n  GridDimensions,\n  ResolvedAxisOptions,\n  Series,\n} from '../types'\n\nfunction defaultAxisOptions<TDatum>(\n  options: AxisOptions<TDatum>\n): ResolvedAxisOptions<AxisOptions<TDatum>> {\n  return {\n    ...options,\n    elementType: options.elementType ?? 'line',\n    // tickCount: options.tickCount ?? 10,\n    // minTickCount: options.minTickCount ?? 1,\n    // maxTickCount: options.maxTickCount ?? 99999999,\n    // tickSizeInner: options.tickSizeInner ?? 6,\n    // tickSizeOuter: options.tickSizeOuter ?? 6,\n    minTickPaddingForRotation: options.minTickPaddingForRotation ?? 10,\n    tickLabelRotationDeg: options.tickLabelRotationDeg ?? 60,\n    innerBandPadding: options.innerBandPadding ?? 0.6,\n    outerBandPadding: options.outerBandPadding ?? 0.2,\n    // showTicks: options.showTicks ?? true,\n    // filterTicks: options.filterTicks ?? (d => d),\n    show: options.show ?? true,\n    stacked: options.stacked ?? false,\n  }\n}\n\nexport default function buildAxisLinear<TDatum>(\n  userOptions: AxisOptions<TDatum>,\n  series: Series<TDatum>[],\n  gridDimensions: GridDimensions,\n  width: number,\n  height: number\n): Axis<TDatum> {\n  const options = defaultAxisOptions(userOptions)\n\n  if (!options.position) {\n    throw new Error(`Chart axes must have a valid 'position' property`)\n  }\n\n  const isVertical = ['left', 'right'].indexOf(options.position) > -1\n\n  // Now we need to figure out the range\n  const range: [number, number] = isVertical\n    ? [gridDimensions.gridHeight, 0]\n    : [0, gridDimensions.gridWidth]\n\n  const outerRange: [number, number] = isVertical ? [height, 0] : [0, width]\n\n  // Give the scale a home\n  return options.scaleType === 'time' || options.scaleType === 'localTime'\n    ? buildTimeAxis(options, series, isVertical, range, outerRange)\n    : options.scaleType === 'linear' || options.scaleType === 'log'\n    ? buildLinearAxis(options, series, isVertical, range, outerRange)\n    : options.scaleType === 'band'\n    ? buildBandAxis(options, series, isVertical, range, outerRange)\n    : (() => {\n        throw new Error('Invalid scale type')\n      })()\n\n  // @ts-ignore\n  // const scaleFormat = scale.tickFormat ? scale.tickFormat() : d => d\n\n  // const userFormat = options?.format\n\n  // const format = userFormat\n  //   ? (value: unknown, index: number) =>\n  //       userFormat(value, index, scaleFormat(value))\n  //   : scaleFormat\n\n  // const resolvedTickCount = options.tickCount\n\n  // const ticks = options.filterTicks(\n  //   options.tickValues ||\n  //     // @ts-ignore\n  //     (scale.ticks ? scale.ticks(resolvedTickCount) : scale.domain())\n  // )\n\n  // const scaleMax =\n  //   options.position === 'bottom'\n  //     ? -gridDimensions.gridHeight\n  //     : options.position === 'left'\n  //     ? gridDimensions.gridWidth\n  //     : options.position === 'top'\n  //     ? gridDimensions.gridHeight\n  //     : -gridDimensions.gridWidth\n\n  // // const directionMultiplier =\n  // //   options.position === 'top' || options.position === 'left' ? -1 : 1\n\n  // const transform = !isVertical ? translateX : translateY\n\n  // const tickSpacing = Math.max(options.tickSizeInner, 0) + options.tickPadding\n\n  // Pass down the axis config (including the scale itself) for posterity\n}\n\nfunction buildTimeAxis<TDatum>(\n  options: ResolvedAxisOptions<AxisTimeOptions<TDatum>>,\n  series: Series<TDatum>[],\n  isVertical: boolean,\n  range: [number, number],\n  outerRange: [number, number]\n): AxisTime<TDatum> {\n  const scaleFn = options.scaleType === 'localTime' ? scaleTime : scaleUtc\n\n  // Now set the range\n  const scale = scaleFn(range)\n\n  const allDatums = series.map(d => d.datums).flat()\n\n  const [minValue, maxValue] = extent(allDatums, datum =>\n    options.getValue(datum.originalDatum)\n  )\n\n  if (minValue === undefined || maxValue === undefined) {\n    console.info({\n      options,\n      series,\n      range,\n      values: allDatums.map(d => options.getValue(d.originalDatum)),\n    })\n    throw new Error('Invalid scale min/max')\n  }\n\n  // Set the domain\n  scale.domain([minValue, maxValue])\n\n  if (typeof options.hardMin === 'number') {\n    scale.domain([options.hardMin, Number(scale.domain()[1])])\n  }\n  if (typeof options.hardMax === 'number') {\n    scale.domain([Number(scale.domain()[0]), options.hardMax])\n  }\n\n  if (options.invert) {\n    scale.domain(Array.from(scale.domain()).reverse())\n  }\n\n  scale.nice()\n\n  const outerScale = scale.copy().range(outerRange)\n\n  // Supplmentary band scale\n  const bandScale = buildImpliedBandScale(options, scale, series, range)\n\n  const defaultFormat = scale.tickFormat()\n\n  const formatters = {} as AxisTime<TDatum>['formatters']\n\n  const scaleFormat = (value: Date) =>\n    options.formatters?.scale?.(value, { ...formatters, scale: undefined }) ??\n    defaultFormat(value)\n\n  const tooltipFormat = (value: Date) =>\n    options.formatters?.tooltip?.(value, {\n      ...formatters,\n      tooltip: undefined,\n    }) ?? scaleFormat(value)\n\n  const cursorFormat = (value: Date) =>\n    options.formatters?.cursor?.(value, { ...formatters, cursor: undefined }) ??\n    tooltipFormat(value)\n\n  Object.assign(formatters, {\n    default: defaultFormat,\n    scale: scaleFormat,\n    tooltip: tooltipFormat,\n    cursor: cursorFormat,\n  })\n\n  return {\n    ...options,\n    axisFamily: 'time',\n    isVertical,\n    scale,\n    range,\n    outerScale,\n    bandScale,\n    formatters: formatters,\n  }\n}\n\nfunction buildLinearAxis<TDatum>(\n  options: ResolvedAxisOptions<AxisLinearOptions<TDatum>>,\n  series: Series<TDatum>[],\n  isVertical: boolean,\n  range: [number, number],\n  outerRange: [number, number]\n): AxisLinear<TDatum> {\n  const scale = options.scaleType === 'log' ? scaleLog() : scaleLinear()\n\n  const allDatums = series.map(d => d.datums).flat(2)\n\n  const [minValue, maxValue] = options.stacked\n    ? extent(\n        (series\n          .map(s => s.datums.map(datum => datum.stackData ?? []))\n          .flat(2) as unknown) as number[]\n      )\n    : extent(allDatums, datum => options.getValue(datum.originalDatum))\n\n  if (minValue === undefined || maxValue === undefined) {\n    console.info({\n      options,\n      series,\n      range,\n      values: allDatums.map(d => options.getValue(d.originalDatum)),\n    })\n    throw new Error('Invalid scale min/max')\n  }\n\n  // Set the domain\n  scale.domain([minValue, maxValue])\n\n  if (typeof options.hardMin === 'number') {\n    scale.domain([options.hardMin, Number(scale.domain()[1])])\n  }\n  if (typeof options.hardMax === 'number') {\n    scale.domain([Number(scale.domain()[0]), options.hardMax])\n  }\n\n  if (options.invert) {\n    scale.domain(Array.from(scale.domain()).reverse())\n  }\n\n  scale.range(range)\n\n  scale.nice()\n\n  const outerScale = scale.copy().range(outerRange)\n\n  const bandScale = buildImpliedBandScale(options, scale, series, range)\n\n  const defaultFormat = scale.tickFormat()\n\n  const formatters = {} as AxisLinear<TDatum>['formatters']\n\n  const scaleFormat = (value: number) =>\n    options.formatters?.scale?.(value, { ...formatters, scale: undefined }) ??\n    defaultFormat(value)\n\n  const tooltipFormat = (value: number) =>\n    options.formatters?.tooltip?.(value, {\n      ...formatters,\n      tooltip: undefined,\n    }) ?? scaleFormat(value)\n\n  const cursorFormat = (value: number) =>\n    options.formatters?.cursor?.(value, { ...formatters, cursor: undefined }) ??\n    tooltipFormat(value)\n\n  Object.assign(formatters, {\n    default: defaultFormat,\n    scale: scaleFormat,\n    tooltip: tooltipFormat,\n    cursor: cursorFormat,\n  })\n\n  return {\n    ...options,\n    axisFamily: 'linear',\n    isVertical,\n    scale,\n    range,\n    outerScale,\n    bandScale,\n    formatters,\n  }\n}\n\nfunction buildBandAxis<TDatum>(\n  options: ResolvedAxisOptions<AxisBandOptions<TDatum>>,\n  series: Series<TDatum>[],\n  isVertical: boolean,\n  range: [number, number],\n  outerRange: [number, number]\n): AxisBand<TDatum> {\n  const domain = Array.from(\n    new Set(\n      series\n        .map(d => d.datums)\n        .flat()\n        .map(datum => options.getValue(datum.originalDatum))\n    )\n  )\n\n  const scale = scaleBand(domain, range)\n    .round(false)\n    .paddingOuter(options.outerBandPadding ?? 0)\n    .paddingInner(options.innerBandPadding ?? 0)\n\n  // Invert if necessary\n  if (options.invert) {\n    scale.domain(Array.from(scale.domain()).reverse())\n  }\n\n  const outerScale = scale.copy().range(outerRange)\n\n  const defaultFormat = (d: { toString: () => string }) => d\n\n  const formatters = {} as AxisBand<TDatum>['formatters']\n\n  const scaleFormat = (value: number) =>\n    options.formatters?.scale?.(value, { ...formatters, scale: undefined }) ??\n    defaultFormat(value)\n\n  const tooltipFormat = (value: number) =>\n    options.formatters?.tooltip?.(value, {\n      ...formatters,\n      tooltip: undefined,\n    }) ?? scaleFormat(value)\n\n  const cursorFormat = (value: number) =>\n    options.formatters?.cursor?.(value, { ...formatters, cursor: undefined }) ??\n    tooltipFormat(value)\n\n  Object.assign(formatters, {\n    default: defaultFormat,\n    scale: scaleFormat,\n    tooltip: tooltipFormat,\n    cursor: cursorFormat,\n  })\n\n  return {\n    ...options,\n    axisFamily: 'band',\n    isVertical,\n    scale,\n    range,\n    outerScale,\n    formatters,\n  }\n}\n\n//\n\nfunction buildImpliedBandScale<TDatum>(\n  options: ResolvedAxisOptions<AxisOptions<TDatum>>,\n  scale: ScaleTime<number, number, never> | ScaleLinear<number, number, never>,\n  series: Series<TDatum>[],\n  range: [number, number]\n) {\n  // Find the two closest points along axis\n\n  let impliedBandWidth: number = Math.max(...range)\n\n  series.forEach(serie => {\n    serie.datums.forEach(d1 => {\n      const one = scale(options.getValue(d1.originalDatum) ?? NaN)\n\n      serie.datums.forEach(d2 => {\n        const two = scale(options.getValue(d2.originalDatum) ?? NaN)\n\n        if (one === two) {\n          return\n        }\n\n        const r = [one, two].sort()\n\n        const diff = Math.abs(r[1] - r[0])\n\n        if (diff < impliedBandWidth) {\n          impliedBandWidth = diff\n        }\n      })\n    })\n  })\n\n  const bandRange = Math.max(...range)\n\n  const bandDomain = d3Range(bandRange / impliedBandWidth)\n\n  const bandScale = scaleBand(bandDomain, range)\n    .round(false)\n    .paddingOuter(options.outerBandPadding ?? 0)\n    .paddingInner(options.innerBandPadding ?? 0)\n\n  return bandScale\n}\n","import React, { MutableRefObject } from 'react'\n\nimport useIsomorphicLayoutEffect from '../hooks/useIsomorphicLayoutEffect'\nimport { Axis, GridDimensions, Position } from '../types'\nimport useChartContext from '../utils/chartContext'\n\nconst getElBox = (el: Element) => {\n  var rect = el.getBoundingClientRect()\n  return {\n    top: Math.round(rect.top),\n    right: Math.round(rect.right),\n    bottom: Math.round(rect.bottom),\n    left: Math.round(rect.left),\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    x: Math.round(rect.x),\n    y: Math.round(rect.y),\n  }\n}\n\nexport default function useMeasure<TDatum>({\n  axis,\n  elRef,\n  gridDimensions,\n  setShowRotated,\n}: {\n  axis: Axis<TDatum>\n  elRef: MutableRefObject<SVGGElement | null>\n  gridDimensions: GridDimensions\n  showRotated: boolean\n  setShowRotated: (value: boolean) => void\n}) {\n  const { useAxisDimensionsAtom } = useChartContext<TDatum>()\n\n  const [axisDimensions, setAxisDimensions] = useAxisDimensionsAtom()\n\n  const axisDimension = React.useMemo(() => {\n    return axisDimensions[axis.position as Position]?.[axis.id!]\n  }, [axisDimensions, axis.position, axis.id])\n\n  // const isLooping = useIsLooping()\n\n  const measureRotation = React.useCallback(() => {\n    if (!elRef.current) {\n      return\n    }\n\n    let gridSize = !axis.isVertical\n      ? gridDimensions.gridWidth\n      : gridDimensions.gridHeight\n\n    const staticLabelDims = Array.from(\n      elRef.current.querySelectorAll('.Axis-Group.outer .tickLabel')\n    ).map(el => getElBox(el))\n\n    // Determine the largest labels on the axis\n    let widestLabel: typeof staticLabelDims[number] | undefined\n\n    staticLabelDims.forEach(label => {\n      let resolvedLabel = widestLabel ?? { width: 0 }\n      if (label.width > 0 && label.width > resolvedLabel.width) {\n        widestLabel = label\n      }\n    })\n\n    let smallestTickGap = gridSize\n\n    if (staticLabelDims.length > 1) {\n      staticLabelDims.forEach((current, i) => {\n        const prev = staticLabelDims[i - 1]\n\n        if (prev) {\n          smallestTickGap = Math.min(\n            smallestTickGap,\n            axis.isVertical ? current.top - prev.top : current.left - prev.left\n          )\n        }\n      })\n    }\n\n    const shouldRotate =\n      (widestLabel?.width || 0) + axis.minTickPaddingForRotation >\n      smallestTickGap\n\n    // if (!isLooping) {\n    // Rotate ticks for non-time horizontal axes\n    if (!axis.isVertical) {\n      setShowRotated(shouldRotate)\n    }\n    // }\n  }, [\n    elRef,\n    axis.isVertical,\n    axis.minTickPaddingForRotation,\n    gridDimensions.gridWidth,\n    gridDimensions.gridHeight,\n    setShowRotated,\n  ])\n\n  const measureDimensions = React.useCallback(() => {\n    if (!elRef.current) {\n      if (axisDimension) {\n        // If the entire axis is hidden, then we need to remove the axis dimensions\n        setAxisDimensions(old => {\n          const newAxes = { ...(old[axis.position] ?? {}) }\n\n          delete newAxes[axis.id!]\n\n          return {\n            ...old,\n            [axis.position]: newAxes,\n          }\n        })\n      }\n      return\n    }\n\n    const newDimensions = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n    }\n\n    const domainEl = elRef.current.querySelector(`.Axis-Group.inner .domain`)\n\n    if (!domainEl) {\n      return\n    }\n\n    const domainDims = getElBox(domainEl)\n\n    const measureDims = Array.from(\n      elRef.current.querySelectorAll('.Axis-Group.inner .tickLabel')\n    ).map(el => getElBox(el))\n\n    // Determine the largest labels on the axis\n    let widestRealLabel = measureDims[0]\n    let tallestRealLabel = measureDims[0]\n\n    measureDims.forEach(d => {\n      if (d.width > 0 && d.width > widestRealLabel.width) {\n        widestRealLabel = d\n      }\n\n      if (d.height > 0 && d.height > tallestRealLabel.height) {\n        tallestRealLabel = d\n      }\n    })\n\n    // Axis overflow measurements\n    if (!axis.isVertical) {\n      if (measureDims.length) {\n        const leftMostLabelDim = measureDims.reduce((d, labelDim) =>\n          labelDim.left < d.left ? labelDim : d\n        )\n        const rightMostLabelDim = measureDims.reduce((d, labelDim) =>\n          labelDim.right > d.right ? labelDim : d\n        )\n\n        newDimensions.left = Math.round(\n          Math.max(0, domainDims.left - leftMostLabelDim?.left)\n        )\n\n        newDimensions.right = Math.round(\n          Math.max(0, rightMostLabelDim?.right - domainDims.right)\n        )\n      }\n\n      newDimensions.height = Math.round(\n        // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +\n        8 + axis.minTickPaddingForRotation + (tallestRealLabel?.height ?? 0)\n      )\n    } else {\n      if (measureDims.length) {\n        const topMostLabelDim = measureDims.reduce((d, labelDim) =>\n          labelDim.top < d.top ? labelDim : d\n        )\n\n        const bottomMostLabelDim = measureDims.reduce((d, labelDim) =>\n          labelDim.bottom > d.bottom ? labelDim : d\n        )\n\n        newDimensions.top = Math.round(\n          Math.max(0, domainDims.top - topMostLabelDim?.top)\n        )\n\n        newDimensions.bottom = Math.round(\n          Math.max(0, bottomMostLabelDim?.bottom - domainDims.bottom)\n        )\n      }\n\n      newDimensions.width = Math.round(\n        // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +\n        8 + axis.minTickPaddingForRotation + (widestRealLabel?.width ?? 0)\n      )\n    }\n\n    // Only update the axisDimensions if something has changed\n    if (\n      // !isLooping &&\n      !axisDimensions ||\n      !axisDimension ||\n      Object.keys(newDimensions).some(key => {\n        // @ts-ignore\n        return newDimensions[key] !== axisDimension[key]\n      })\n    ) {\n      setAxisDimensions(old => ({\n        ...old,\n        [axis.position]: {\n          ...(old[axis.position] ?? {}),\n          [axis.id!]: newDimensions,\n        },\n      }))\n    }\n  }, [\n    axis.id,\n    axis.isVertical,\n    axis.position,\n    axis.minTickPaddingForRotation,\n    axisDimension,\n    axisDimensions,\n    elRef,\n    setAxisDimensions,\n  ])\n\n  // Measure after if needed\n  useIsomorphicLayoutEffect(() => {\n    measureRotation()\n  }, [measureRotation])\n\n  useIsomorphicLayoutEffect(() => {\n    measureDimensions()\n  }, [measureRotation])\n}\n","import { ScaleLinear, ScaleTime } from 'd3-scale'\nimport React from 'react'\n\nimport { Axis, AxisTime } from '../types'\nimport { getTickPx, translate } from '../utils/Utils'\nimport useChartContext from '../utils/chartContext'\n//\nimport useMeasure from './AxisLinear.useMeasure'\n\nexport default function AxisLinearComp<TDatum>(axis: Axis<TDatum>) {\n  const [showRotated, setShowRotated] = React.useState(false)\n  const {\n    getOptions,\n    gridDimensions,\n    width,\n    height,\n  } = useChartContext<TDatum>()\n\n  const { dark, showDebugAxes } = getOptions()\n\n  const elRef = React.useRef<SVGGElement>(null)\n\n  useMeasure({\n    axis,\n    elRef,\n    gridDimensions,\n    showRotated,\n    setShowRotated,\n  })\n\n  const renderAxis = (isOuter: boolean) => {\n    const isRotated = !isOuter && showRotated\n\n    const scale = isOuter ? axis.outerScale : axis.scale\n    const [rangeStart, rangeEnd] = scale.range()\n\n    const getTicks = (\n      scale: ScaleTime<any, any> | ScaleLinear<any, any>,\n      num: number\n    ) => {\n      if (scale.ticks) {\n        return scale.ticks(num)\n      }\n\n      return scale.domain()\n    }\n\n    const resolvedHeight = isOuter ? height : gridDimensions.gridHeight\n    const resolvedWidth = isOuter ? width : gridDimensions.gridWidth\n\n    const [lineFrom, lineTo] =\n      axis.position === 'left'\n        ? [\n            { x: 0, y: rangeStart },\n            { x: 0, y: rangeEnd },\n          ]\n        : axis.position === 'right'\n        ? [\n            { x: resolvedWidth, y: rangeStart },\n            { x: resolvedWidth, y: rangeEnd },\n          ]\n        : axis.position === 'top'\n        ? [\n            { x: rangeStart, y: 0 },\n            { x: rangeEnd, y: 0 },\n          ]\n        : [\n            { x: rangeStart, y: resolvedHeight },\n            { x: rangeEnd, y: resolvedHeight },\n          ]\n\n    return (\n      <g\n        key={`Axis-Group ${isOuter ? 'outer' : 'inner'}`}\n        className={`Axis-Group ${isOuter ? 'outer' : 'inner'}`}\n        style={{\n          transform: isOuter\n            ? undefined\n            : translate(gridDimensions.gridX, gridDimensions.gridY),\n        }}\n      >\n        <g\n          className={`Axis`}\n          style={{\n            ...(isOuter\n              ? {\n                  opacity: showDebugAxes ? 0.5 : 0,\n                  pointerEvents: 'none',\n                }\n              : {\n                  opacity: 1,\n                  pointerEvents: 'all',\n                }),\n          }}\n        >\n          <line\n            className=\"domain\"\n            x1={lineFrom.x}\n            y1={lineFrom.y}\n            x2={lineTo.x}\n            y2={lineTo.y}\n            stroke={dark ? 'rgba(255,255,255, .2)' : 'rgba(0,0,0, .2)'}\n          />\n          {getTicks(scale as ScaleTime<any, any>, 10).map((tick, i) => {\n            const px = getTickPx(scale, tick)\n\n            const [tickFrom, tickTo, gridTo] =\n              axis.position === 'left'\n                ? [\n                    { x: 0, y: px },\n                    { x: -8, y: px },\n                    { x: resolvedWidth, y: px },\n                  ]\n                : axis.position === 'right'\n                ? [\n                    { x: resolvedWidth, y: px },\n                    { x: resolvedWidth + 8, y: px },\n                    { x: 0, y: px },\n                  ]\n                : axis.position === 'top'\n                ? [\n                    { x: px, y: 0 },\n                    { x: px, y: -8 },\n                    { x: px, y: resolvedHeight },\n                  ]\n                : [\n                    { x: px, y: resolvedHeight },\n                    { x: px, y: resolvedHeight + 8 },\n                    { x: px, y: 0 },\n                  ]\n\n            let { x: tickLabelX, y: tickLabelY } = tickTo\n\n            if (axis.position === 'top') {\n              tickLabelY -= 5\n            } else if (axis.position === 'bottom') {\n              tickLabelY += 5\n            } else if (axis.position === 'left') {\n              tickLabelX -= 5\n            } else if (axis.position === 'right') {\n              tickLabelX += 5\n            }\n\n            return (\n              <g key={`vx-tick-${tick}-${i}`} className={'tick'}>\n                {(axis.showGrid ?? true) && !isOuter ? (\n                  <line\n                    x1={tickFrom.x}\n                    y1={tickFrom.y}\n                    x2={gridTo.x}\n                    y2={gridTo.y}\n                    stroke={\n                      dark ? 'rgba(255,255,255, .05)' : 'rgba(0,0,0, .05)'\n                    }\n                  />\n                ) : null}\n                {!isOuter ? (\n                  <line\n                    x1={tickFrom.x}\n                    y1={tickFrom.y}\n                    x2={tickTo.x}\n                    y2={tickTo.y}\n                    stroke={dark ? 'rgba(255,255,255, .2)' : 'rgba(0,0,0, .2)'}\n                  />\n                ) : null}\n                <text\n                  className=\"tickLabel\"\n                  style={{\n                    fontSize: 10,\n                    fill: dark ? 'rgba(255,255,255, .7)' : 'rgba(0,0,0, .7)',\n                    dominantBaseline: isRotated\n                      ? 'central'\n                      : axis.position === 'bottom'\n                      ? 'hanging'\n                      : axis.position === 'top'\n                      ? 'alphabetic'\n                      : 'central',\n                    textAnchor: isRotated\n                      ? 'end'\n                      : axis.position === 'right'\n                      ? 'start'\n                      : axis.position === 'left'\n                      ? 'end'\n                      : 'middle',\n                  }}\n                  transform={`translate(${tickLabelX}, ${tickLabelY}) rotate(${\n                    isRotated ? (axis.position === 'top' ? 60 : -60) : 0\n                  })`}\n                >\n                  {(axis as AxisTime<any>).formatters.scale(tick as Date)}\n                </text>\n              </g>\n            )\n          })}\n        </g>\n      </g>\n    )\n  }\n\n  return axis.show ? (\n    <g ref={elRef}>\n      {renderAxis(false)}\n      {renderAxis(true)}\n    </g>\n  ) : null\n}\n","import React from 'react'\n\nexport default function useLatestWhen<T>(obj: T, when: boolean = true) {\n  const ref = React.useRef<T | null>(when ? obj : null)\n\n  if (when) {\n    ref.current = obj\n  }\n\n  return ref.current\n}\n","import * as React from 'react'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function usePortalElement() {\n  const [portalEl, setPortalEl] = React.useState<HTMLDivElement | null>()\n\n  useIsomorphicLayoutEffect(() => {\n    if (!portalEl) {\n      let element = document.getElementById(\n        'react-charts-portal'\n      ) as HTMLDivElement\n\n      if (!element) {\n        element = document.createElement('div')\n\n        element.setAttribute('id', 'react-charts-portal')\n\n        Object.assign(element.style, {\n          pointerEvents: 'none',\n          position: 'fixed',\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0,\n          'z-index': 99999999999,\n        })\n\n        document.body.append(element)\n      }\n\n      setPortalEl(element)\n    }\n  })\n\n  return portalEl\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport * as TSTB from 'ts-toolbelt'\n\nimport { animated, config, useSpring } from '@react-spring/web'\n\n// import useIsScrolling from '../hooks/useIsScrolling'\nimport useLatestWhen from '../hooks/useLatestWhen'\nimport usePortalElement from '../hooks/usePortalElement'\nimport { AxisTime, CursorOptions, Datum } from '../types'\nimport { translate } from '../utils/Utils'\n//\nimport useChartContext from '../utils/chartContext'\n\ntype ResolvedCursorOptions = TSTB.Object.Required<\n  CursorOptions,\n  'show' | 'showLine' | 'showLabel'\n>\n\n//\n\nconst getLineBackgroundColor = (dark?: boolean) =>\n  dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)'\n\nconst getBackgroundColor = (dark?: boolean) =>\n  dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)'\n\nfunction defaultCursor(options: CursorOptions): ResolvedCursorOptions {\n  return {\n    ...options,\n    show: options.show ?? true,\n    showLine: options.showLine ?? true,\n    showLabel: options.showLabel ?? true,\n  }\n}\n\nexport default function Cursors<TDatum>() {\n  const { getOptions } = useChartContext<TDatum>()\n\n  let primaryOptions = getOptions().primaryCursor ?? true\n  let secondaryOptions = getOptions().secondaryCursor ?? true\n\n  const resolvedPrimaryOptions = React.useMemo(\n    () =>\n      defaultCursor(\n        !primaryOptions\n          ? { show: false }\n          : typeof primaryOptions === 'boolean'\n          ? {}\n          : primaryOptions\n      ),\n    [primaryOptions]\n  )\n\n  const resolvedSecondaryOptions = React.useMemo(\n    () =>\n      defaultCursor(\n        !secondaryOptions\n          ? { show: false }\n          : typeof secondaryOptions === 'boolean'\n          ? {}\n          : secondaryOptions\n      ),\n    [secondaryOptions]\n  )\n\n  return (\n    <>\n      <Cursor primary options={resolvedPrimaryOptions} />\n      <Cursor options={resolvedSecondaryOptions} />\n    </>\n  )\n}\n\nfunction Cursor<TDatum>(props: {\n  primary?: boolean\n  options: ResolvedCursorOptions\n}) {\n  const {\n    getOptions,\n    svgRect,\n    gridDimensions,\n    useFocusedDatumAtom,\n    primaryAxis,\n    secondaryAxes,\n  } = useChartContext<TDatum>()\n\n  const [focusedDatum] = useFocusedDatumAtom()\n  const latestFocusedDatum = useLatestWhen(focusedDatum, !!focusedDatum)\n\n  const secondaryAxis = secondaryAxes.find(\n    d => d.id === props.options.axisId || latestFocusedDatum?.secondaryAxisId\n  )!\n\n  const axis = props.primary ? primaryAxis : secondaryAxis\n\n  const siblingAxis = props.primary ? secondaryAxis : primaryAxis\n\n  const resolveValue = (d: Datum<TDatum> | null) =>\n    props.options.value ??\n    (d\n      ? axis.stacked\n        ? d.stackData?.[1]\n        : axis.getValue(d?.originalDatum)\n      : undefined)\n\n  const value = resolveValue(focusedDatum)\n  const latestValue = resolveValue(latestFocusedDatum)\n\n  // Get the sibling range\n  const siblingRange = siblingAxis.scale.range()\n\n  let x\n  let y\n  let x1\n  let x2\n  let y1\n  let y2\n  let alignPctX\n  let alignPctY\n\n  const bandWidth = axis.axisFamily === 'band' ? axis.scale.bandwidth() : 1\n\n  const px = axis.scale(latestValue)\n\n  const show = typeof value !== 'undefined' && !Number.isNaN(value)\n\n  // Vertical alignment\n  if (axis.isVertical) {\n    y = px\n    y1 = (y ?? 0) - 1\n    y2 = (y ?? 0) + bandWidth\n    if (axis.position === 'left') {\n      x1 = siblingRange[0]\n      x2 = siblingRange[1]\n    } else {\n      x1 = siblingRange[1]\n      x2 = siblingRange[0]\n    }\n  } else {\n    x = px\n    x1 = (x ?? 0) - 1\n    x2 = (x ?? 0) + bandWidth\n    if (axis.position === 'top') {\n      y1 = siblingRange[0]\n      y2 = siblingRange[1]\n    } else {\n      y1 = siblingRange[1]\n      y2 = siblingRange[0]\n    }\n  }\n\n  const lineStartX = Math.min(x1, x2)\n  const lineStartY = Math.min(y1, y2)\n  const lineEndX = Math.max(x1, x2)\n  const lineEndY = Math.max(y1, y2)\n  const lineHeight = Math.max(lineEndY - lineStartY, 0)\n  const lineWidth = Math.max(lineEndX - lineStartX, 0)\n\n  let bubbleX\n  let bubbleY\n\n  // Bubble placement\n  if (axis.isVertical) {\n    if (axis.position === 'left') {\n      bubbleX = lineStartX\n    } else {\n      bubbleX = lineEndX\n    }\n\n    bubbleY = lineStartY + lineHeight / 2\n  } else {\n    if (axis.position === 'top') {\n      bubbleY = lineStartY\n    } else {\n      bubbleY = lineEndY\n    }\n\n    bubbleX = lineStartX + lineWidth / 2\n  }\n\n  // Bubble anchoring\n  if (axis.isVertical) {\n    alignPctY = -50\n    if (axis.position === 'left') {\n      alignPctX = -100\n    } else {\n      alignPctX = 0\n    }\n  } else {\n    alignPctX = -50\n    if (axis.position === 'top') {\n      alignPctY = -100\n    } else {\n      alignPctY = 0\n    }\n  }\n\n  const formattedValue = (axis as AxisTime<any>).formatters.cursor(latestValue)\n\n  // const isScrolling = useIsScrolling(200)\n\n  const lineSpring = useSpring({\n    transform: translate(lineStartX, lineStartY),\n    width: `${lineWidth}px`,\n    height: `${lineHeight}px`,\n    config: config.stiff,\n    // immediate: isScrolling,\n  })\n\n  const bubbleSpring = useSpring({\n    transform: translate(bubbleX, bubbleY),\n    config: config.stiff,\n    // immediate: isScrolling,\n  })\n\n  const portalEl = usePortalElement()\n\n  return portalEl\n    ? ReactDOM.createPortal(\n        <div\n          style={{\n            pointerEvents: 'none',\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            transform: translate(\n              svgRect.left + gridDimensions.gridX,\n              svgRect.top + gridDimensions.gridY\n            ),\n            opacity: show ? 1 : 0,\n            transition: 'all .3s ease',\n          }}\n          className=\"Cursor\"\n        >\n          {/* Render the cursor line */}\n          {props.options.showLine ? (\n            <animated.div\n              style={{\n                ...lineSpring,\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                background: getLineBackgroundColor(getOptions().dark),\n              }}\n            />\n          ) : null}\n          {/* Render the cursor bubble */}\n          {props.options.showLabel ? (\n            <animated.div\n              style={{\n                ...bubbleSpring,\n                position: 'absolute',\n                top: 0,\n                left: 0,\n              }}\n            >\n              {/* Render the cursor label */}\n              <div\n                style={{\n                  padding: '5px',\n                  fontSize: '10px',\n                  background: getBackgroundColor(getOptions().dark),\n                  color: getBackgroundColor(!getOptions().dark),\n                  borderRadius: '3px',\n                  position: 'relative',\n                  transform: `translate3d(${alignPctX}%, ${alignPctY}%, 0)`,\n                  whiteSpace: 'nowrap',\n                }}\n              >\n                {formattedValue}\n              </div>\n            </animated.div>\n          ) : null}\n        </div>,\n        portalEl\n      )\n    : null\n}\n","import React from 'react'\n\nimport useRect, { HasBoundingClientRect } from './useRect'\n\n//\n\n//\n\ntype AlignMode =\n  | 'center'\n  | 'start'\n  | 'end'\n  | 'top'\n  | 'right'\n  | 'bottom'\n  | 'left'\n\ntype Side = 'left' | 'right' | 'top' | 'bottom'\ntype SideOption = Side | `${Side} ${AlignMode}`\ntype SideAlign = [Side, AlignMode]\n\ntype StartKey = 'left' | 'top'\ntype LengthKey = 'width' | 'height'\n\ntype Dims = {\n  left: number\n  top: number\n  right: number\n  bottom: number\n  width: number\n  height: number\n}\n\n// These are the keys used internally to look up and measure\n// different sides of a bounding box within another\nconst sideSchemas = {\n  left: {\n    side: 'left',\n    startKey: 'left',\n    lengthKey: 'width',\n    crossStartKey: 'top',\n    crossLengthKey: 'height',\n    fromEnd: false,\n  },\n  right: {\n    side: 'right',\n    startKey: 'left',\n    lengthKey: 'width',\n    crossStartKey: 'top',\n    crossLengthKey: 'height',\n    fromEnd: true,\n  },\n  top: {\n    side: 'top',\n    startKey: 'top',\n    lengthKey: 'height',\n    crossStartKey: 'left',\n    crossLengthKey: 'width',\n    fromEnd: false,\n  },\n  bottom: {\n    side: 'bottom',\n    startKey: 'top',\n    lengthKey: 'height',\n    crossStartKey: 'left',\n    crossLengthKey: 'width',\n    fromEnd: true,\n  },\n} as const\n\n// This is the final Tootlip component. It's a render prop\n// that lets you attach handlers to elements, and render a tooltip\n// anchored to them in relation to the parent portal container (either the only\n// one defined or the one referenced by Id).\nexport function useAnchor(options: {\n  show: boolean\n  useLargest?: boolean\n  side: SideOption | SideOption[]\n  portalEl: HasBoundingClientRect | null | undefined\n  anchorEl: HasBoundingClientRect | null | undefined\n  tooltipEl: HasBoundingClientRect | null | undefined\n}) {\n  const portalDims = useRect(options.portalEl, { enabled: options.show })\n  const anchorDims = useRect(options.anchorEl, { enabled: options.show })\n  const tooltipDims = useRect(options.tooltipEl, {\n    enabled: options.show,\n  })\n\n  const sides = React.useMemo(() => {\n    const preSides = Array.isArray(options.side) ? options.side : [options.side]\n    return preSides.map(alignStr => {\n      const [side, align = 'center'] = alignStr.split(' ') as [Side, AlignMode]\n      const incompatibleSide = !['top', 'right', 'bottom', 'left'].find(\n        d => side === d\n      )\n\n      if (incompatibleSide) {\n        throw new Error(\n          `react-sticker: \"${side}\" is not a valid side! Must be one of ['top', 'right', 'bottom', 'left'].`\n        )\n      }\n\n      const incompatibleAlign = ![\n        'center',\n        'start',\n        'end',\n        'top',\n        'right',\n        'bottom',\n        'left',\n      ].find(d => align === d)\n\n      if (incompatibleAlign) {\n        throw new Error(\n          `react-sticker: \"${align}\" is not a valid side-alignment! Must be one of ['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].`\n        )\n      }\n\n      return [side, align] as [Side, AlignMode]\n    })\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(options.side)])\n\n  // IF we have all of the dimensions needed to calculate\n  // fits, then calculate the fit\n  const ready = portalDims && tooltipDims && anchorDims\n\n  const fit = React.useMemo(\n    () =>\n      ready\n        ? fitOnBestSide({\n            portalDims,\n            tooltipDims,\n            anchorDims,\n            sides,\n            useLargest: options.useLargest,\n          })\n        : null,\n    [anchorDims, options.useLargest, portalDims, ready, sides, tooltipDims]\n  )\n\n  return {\n    fit,\n    style: {\n      position: 'absolute' as const,\n      visibility: ready ? ('visible' as const) : ('hidden' as const),\n      // The fit styles are applied here from the best fit\n      ...fit?.style,\n    },\n  }\n}\n\n// This function selects the best side for the tooltip by using\n// the ranked fits.\nfunction fitOnBestSide({\n  portalDims,\n  tooltipDims,\n  anchorDims,\n  sides,\n  useLargest,\n}: {\n  portalDims: Dims\n  tooltipDims: Dims\n  anchorDims: Dims\n  sides: SideAlign[]\n  useLargest?: boolean\n}) {\n  const fits = sides.map(([side, align]) =>\n    measureFit({\n      ...sideSchemas[side],\n      align,\n      portalDims,\n      tooltipDims,\n      anchorDims,\n    })\n  )\n\n  if (useLargest) {\n    fits.sort((a, b) => b.fitRatio - a.fitRatio)\n    return fits[0]\n  }\n\n  return fits.find(fit => fit.fitRatio >= 1) || fits[0]\n}\n\n// This function takes a side and bunch of calculated dimensions from\n// the portal, tooltip and target. Then it returns\n// the percentage fit and the style to achieve this specific fit\nfunction measureFit({\n  side,\n  align,\n  startKey,\n  lengthKey,\n  crossStartKey,\n  crossLengthKey,\n  fromEnd,\n  portalDims,\n  tooltipDims,\n  anchorDims,\n}: {\n  side: Side\n  align: AlignMode\n  startKey: StartKey\n  lengthKey: LengthKey\n  crossStartKey: StartKey\n  crossLengthKey: LengthKey\n  fromEnd: boolean\n  portalDims: Dims\n  tooltipDims: Dims\n  anchorDims: Dims\n}) {\n  const parentStart = portalDims[startKey]\n  const parentLength = portalDims[lengthKey]\n  const crossParentStart = portalDims[crossStartKey]\n  const crossParentLength = portalDims[crossLengthKey]\n  const anchorStart = anchorDims[startKey] - portalDims[startKey]\n  const anchorLength = anchorDims[lengthKey]\n  const crossAnchorStart = anchorDims[crossStartKey]\n  const crossAnchorLength = anchorDims[crossLengthKey]\n  const crossAnchorWidth = anchorDims[crossLengthKey]\n  const targetLength = tooltipDims[lengthKey]\n  const crossTargetLength = tooltipDims[crossLengthKey]\n\n  let targetStart: number\n  let fitRatio: number\n\n  if (!fromEnd) {\n    targetStart = anchorStart - targetLength\n    fitRatio = Math.min(anchorStart / targetLength)\n  } else {\n    targetStart = anchorStart + anchorLength\n    fitRatio = (parentLength - (anchorStart + anchorLength)) / targetLength\n  }\n\n  targetStart = Math.max(parentStart, Math.min(targetStart, parentLength))\n\n  let crossTargetStart: number\n\n  if (startKey === 'left') {\n    if (align === 'top') {\n      align = 'start'\n    } else if (align === 'bottom') {\n      align = 'end'\n    }\n  } else {\n    if (align === 'left') {\n      align = 'start'\n    } else if (align === 'right') {\n      align = 'end'\n    }\n  }\n\n  if (!['start', 'center', 'end'].includes(align)) {\n    align = 'center'\n  }\n\n  if (align === 'start') {\n    crossTargetStart = crossAnchorStart\n  } else if (align === 'end') {\n    crossTargetStart = crossAnchorStart + crossAnchorWidth - crossTargetLength\n  } else {\n    crossTargetStart =\n      crossAnchorStart + crossAnchorLength / 2 - crossTargetLength / 2\n  }\n\n  crossTargetStart = Math.max(\n    crossParentStart,\n    Math.min(crossTargetStart, crossParentLength - crossTargetLength)\n  )\n\n  return {\n    side,\n    align,\n    startKey,\n    lengthKey,\n    crossStartKey,\n    crossLengthKey,\n    fromEnd,\n    portalDims,\n    tooltipDims,\n    anchorDims,\n    fitRatio,\n    style: {\n      [startKey]: targetStart,\n      [crossStartKey]: crossTargetStart,\n    } as Record<StartKey, number>,\n  }\n}\n","import React from 'react'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function usePrevious<T>(val: T) {\n  const ref = React.useRef<T>()\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = val\n  }, [val])\n\n  return ref.current\n}\n","import { sum } from 'd3-array'\nimport React, { CSSProperties } from 'react'\n\nimport { useAnchor } from '../hooks/useAnchor'\nimport { Axis, AxisTime, Datum, RequiredChartOptions } from '../types'\n\n//\n//\n\nconst showCount = 10\n\nconst triangleSize = 7\n\nconst getBackgroundColor = (dark?: boolean) =>\n  dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)'\n\nexport type TooltipRendererProps<TDatum> = {\n  focusedDatum: Datum<TDatum> | null\n  getOptions: () => RequiredChartOptions<TDatum>\n  primaryAxis: Axis<TDatum>\n  secondaryAxis: Axis<TDatum>\n  getDatumStyle: (datum: Datum<TDatum>) => CSSProperties\n  anchorFit: ReturnType<typeof useAnchor>\n}\n\nexport default function TooltipRenderer<TDatum>(\n  props: TooltipRendererProps<TDatum>\n) {\n  if (!props.focusedDatum) {\n    return null\n  }\n\n  const { primaryAxis, secondaryAxis, getDatumStyle, focusedDatum } = props\n\n  const { groupingMode, dark } = props.getOptions()\n\n  const groupDatums = props.focusedDatum?.group ?? []\n\n  const resolvedShowCount = showCount % 2 === 0 ? showCount : showCount + 1\n  const length = groupDatums.length\n\n  // Get the focused series' index\n  const activeIndex = groupDatums.findIndex(d => d === focusedDatum)\n  // Get the start by going back half of the showCount\n  let start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0\n  // Make sure it's at least 0\n  start = Math.max(start, 0)\n  // Use the start and add the showCount to get the end\n  let end = activeIndex > -1 ? start + resolvedShowCount : length\n  // Don't let the end go passed the length\n  end = Math.min(end, length)\n  // Double check we aren't clipping the start\n  start = Math.max(end - resolvedShowCount, 0)\n  // Slice the datums by start and end\n  const visibleSortedGroupDatums = groupDatums.slice(start, end)\n  // Detect if we have previous items\n  const hasPrevious = start > 0\n  // Or next items\n  const hasNext = end < length\n\n  const finalAlign = `${props.anchorFit.fit?.side}-${props.anchorFit.fit?.align}`\n\n  let arrowPosition\n  let triangleStyles\n\n  if (!arrowPosition) {\n    if (finalAlign === 'left-center') {\n      arrowPosition = 'right'\n    } else if (finalAlign === 'right-center') {\n      arrowPosition = 'left'\n    } else if (finalAlign === 'top-center') {\n      arrowPosition = 'bottom'\n    } else if (finalAlign === 'bottom-center') {\n      arrowPosition = 'top'\n    } else if (finalAlign === 'right-start') {\n      arrowPosition = 'bottomLeft'\n    } else if (finalAlign === 'right-end') {\n      arrowPosition = 'topLeft'\n    } else if (finalAlign === 'left-start') {\n      arrowPosition = 'bottomRight'\n    } else if (finalAlign === 'left-end') {\n      arrowPosition = 'topRight'\n    }\n  }\n\n  const backgroundColor = getBackgroundColor(dark)\n\n  if (arrowPosition === 'bottom') {\n    triangleStyles = {\n      top: '100%',\n      left: '50%',\n      transform: 'translate3d(-50%, 0%, 0)',\n      borderLeft: `${triangleSize * 0.8}px solid transparent`,\n      borderRight: `${triangleSize * 0.8}px solid transparent`,\n      borderTop: `${triangleSize}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'top') {\n    triangleStyles = {\n      top: '0%',\n      left: '50%',\n      transform: 'translate3d(-50%, -100%, 0)',\n      borderLeft: `${triangleSize * 0.8}px solid transparent`,\n      borderRight: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'right') {\n    triangleStyles = {\n      top: '50%',\n      left: '100%',\n      transform: 'translate3d(0%, -50%, 0)',\n      borderTop: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize * 0.8}px solid transparent`,\n      borderLeft: `${triangleSize}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'left') {\n    triangleStyles = {\n      top: '50%',\n      left: '0%',\n      transform: 'translate3d(-100%, -50%, 0)',\n      borderTop: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize * 0.8}px solid transparent`,\n      borderRight: `${triangleSize}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'topRight') {\n    triangleStyles = {\n      top: '0%',\n      left: '100%',\n      transform: 'translate3d(-50%, -50%, 0) rotate(-45deg)',\n      borderTop: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize * 0.8}px solid transparent`,\n      borderLeft: `${triangleSize * 2}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'bottomRight') {\n    triangleStyles = {\n      top: '100%',\n      left: '100%',\n      transform: 'translate3d(-50%, -50%, 0) rotate(45deg)',\n      borderTop: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize * 0.8}px solid transparent`,\n      borderLeft: `${triangleSize * 2}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'topLeft') {\n    triangleStyles = {\n      top: '0%',\n      left: '0%',\n      transform: 'translate3d(-50%, -50%, 0) rotate(45deg)',\n      borderTop: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize * 0.8}px solid transparent`,\n      borderRight: `${triangleSize * 2}px solid ${backgroundColor}`,\n    }\n  } else if (arrowPosition === 'bottomLeft') {\n    triangleStyles = {\n      top: '100%',\n      left: '0%',\n      transform: 'translate3d(-50%, -50%, 0) rotate(-45deg)',\n      borderTop: `${triangleSize * 0.8}px solid transparent`,\n      borderBottom: `${triangleSize * 0.8}px solid transparent`,\n      borderRight: `${triangleSize * 2}px solid ${backgroundColor}`,\n    }\n  } else {\n    triangleStyles = {\n      opacity: 0,\n    }\n  }\n\n  return (\n    <div\n      style={{\n        position: 'relative',\n        fontSize: '10px',\n        padding: '5px',\n        background: getBackgroundColor(dark),\n        color: dark ? 'black' : 'white',\n        borderRadius: '3px',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          width: 0,\n          height: 0,\n          ...triangleStyles,\n        }}\n      />\n      <div>\n        <div\n          style={{\n            marginBottom: '3px',\n            textAlign: 'center',\n          }}\n        >\n          {groupingMode === 'series' ? (\n            <strong>{focusedDatum.seriesLabel}</strong>\n          ) : groupingMode === 'secondary' ? (\n            <strong>\n              {(secondaryAxis as AxisTime<any>).formatters.tooltip(\n                secondaryAxis.getValue(focusedDatum.originalDatum)\n              )}\n            </strong>\n          ) : (\n            <strong>\n              {(primaryAxis as AxisTime<any>).formatters.tooltip(\n                primaryAxis.getValue(focusedDatum.originalDatum)\n              )}\n            </strong>\n          )}\n        </div>\n        <table\n          style={{\n            whiteSpace: 'nowrap',\n          }}\n        >\n          <tbody>\n            {hasPrevious ? (\n              <tr\n                style={{\n                  opacity: 0.8,\n                }}\n              >\n                <td />\n                <td>...</td>\n                <td />\n              </tr>\n            ) : null}\n            {visibleSortedGroupDatums.map((sortedDatum, i) => {\n              const active = sortedDatum === focusedDatum\n\n              return (\n                <tr\n                  key={i}\n                  style={{\n                    opacity: active ? 1 : 0.8,\n                    fontWeight: active ? 'bold' : undefined,\n                  }}\n                >\n                  <td\n                    style={{\n                      display: 'flex',\n                      alignItems: 'center',\n                      justifyContent: 'center',\n                    }}\n                  >\n                    <svg width=\"14\" height=\"14\">\n                      <circle\n                        cx=\"7\"\n                        cy=\"7\"\n                        r=\"5\"\n                        style={{\n                          ...getDatumStyle(sortedDatum),\n                          stroke: dark ? 'black' : 'white',\n                          strokeWidth: active ? 2 : 1,\n                        }}\n                      />\n                    </svg>\n                  </td>\n                  {groupingMode === 'series' ? (\n                    <React.Fragment>\n                      <td>\n                        {(primaryAxis as AxisTime<any>).formatters.tooltip(\n                          primaryAxis.getValue(sortedDatum.originalDatum)\n                        )}\n                        : &nbsp;\n                      </td>\n                      <td\n                        style={{\n                          textAlign: 'right',\n                        }}\n                      >\n                        {(secondaryAxis as AxisTime<any>).formatters.tooltip(\n                          secondaryAxis.getValue(sortedDatum.originalDatum)\n                        )}\n                      </td>\n                    </React.Fragment>\n                  ) : groupingMode === 'secondary' ? (\n                    <React.Fragment>\n                      <td>{sortedDatum.seriesLabel}: &nbsp;</td>\n                      <td\n                        style={{\n                          textAlign: 'right',\n                        }}\n                      >\n                        {(primaryAxis as AxisTime<any>).formatters.tooltip(\n                          primaryAxis.getValue(sortedDatum.originalDatum)\n                        )}\n                      </td>\n                    </React.Fragment>\n                  ) : (\n                    <React.Fragment>\n                      <td>{sortedDatum.seriesLabel}: &nbsp;</td>\n                      <td\n                        style={{\n                          textAlign: 'right',\n                        }}\n                      >\n                        {(secondaryAxis as AxisTime<any>).formatters.tooltip(\n                          secondaryAxis.getValue(sortedDatum.originalDatum)\n                        )}\n                      </td>\n                    </React.Fragment>\n                  )}\n                </tr>\n              )\n            })}\n            {hasNext ? (\n              <tr\n                style={{\n                  opacity: 0.8,\n                }}\n              >\n                <td />\n                <td>...</td>\n                <td />\n              </tr>\n            ) : null}\n            {secondaryAxis.stacked && (focusedDatum.group ?? []).length > 1 ? (\n              <tr>\n                <td\n                  style={{\n                    paddingTop: '5px',\n                  }}\n                >\n                  <div\n                    style={{\n                      width: '12px',\n                      height: '12px',\n                      backgroundColor: dark\n                        ? 'rgba(0, 26, 39, 0.3)'\n                        : 'rgba(255,255,255,.2)',\n                      borderRadius: '50px',\n                    }}\n                  />\n                </td>\n                <td\n                  style={{\n                    paddingTop: '5px',\n                  }}\n                >\n                  Total: &nbsp;\n                </td>\n                <td\n                  style={{\n                    paddingTop: '5px',\n                  }}\n                >\n                  {/* {secondaryAxis.format(\n                  [...focusedDatum.group].reverse()[0].totalValue,\n                  -1\n                )} */}\n                  {sum(focusedDatum.group ?? [], d =>\n                    secondaryAxis.getValue(d.originalDatum)\n                  )}\n                </td>\n              </tr>\n            ) : null}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  )\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { useSpring, animated } from '@react-spring/web'\n\nimport { useAnchor } from '../hooks/useAnchor'\n// import useIsScrolling from '../hooks/useIsScrolling'\nimport useLatestWhen from '../hooks/useLatestWhen'\nimport usePortalElement from '../hooks/usePortalElement'\nimport usePrevious from '../hooks/usePrevious'\nimport { Datum, ResolvedTooltipOptions, TooltipOptions } from '../types'\n//\nimport useChartContext from '../utils/chartContext'\nimport TooltipRenderer from './TooltipRenderer'\n\n//\n\nfunction defaultTooltip<TDatum>(\n  options: TooltipOptions<TDatum> = {}\n): ResolvedTooltipOptions<TDatum> {\n  return {\n    ...options,\n    align: options.align ?? 'auto',\n    alignPriority: options.alignPriority ?? [\n      'right',\n      'topRight',\n      'bottomRight',\n      'left',\n      'topLeft',\n      'bottomLeft',\n      'top',\n      'bottom',\n    ],\n    padding: options.padding ?? 5,\n    tooltipArrowPadding: options.tooltipArrowPadding ?? 7,\n    // anchor: options.anchor ?? 'closest',\n    render: options.render ?? TooltipRenderer,\n  }\n}\n\nexport default function Tooltip<TDatum>(): React.ReactPortal | null {\n  const {\n    useFocusedDatumAtom,\n    getOptions,\n    primaryAxis,\n    secondaryAxes,\n    getDatumStatusStyle,\n    // getSeriesStatusStyle,\n  } = useChartContext<TDatum>()\n\n  const [focusedDatum] = useFocusedDatumAtom()\n  const latestFocusedDatum = useLatestWhen(focusedDatum, !!focusedDatum)\n\n  const preTooltipOptions = getOptions().tooltip ?? true\n\n  const secondaryAxis =\n    secondaryAxes.find(d => d.id === latestFocusedDatum?.secondaryAxisId) ??\n    secondaryAxes[0]\n\n  const tooltipOptions = React.useMemo(\n    () =>\n      defaultTooltip(\n        typeof preTooltipOptions === 'boolean' ? {} : preTooltipOptions\n      ),\n    [preTooltipOptions]\n  )\n\n  let anchorRect: DOMRect | null = null\n\n  if (latestFocusedDatum) {\n    anchorRect = latestFocusedDatum.element?.getBoundingClientRect() ?? null\n  }\n\n  const portalEl = usePortalElement()\n\n  const [tooltipEl, setTooltipEl] = React.useState<HTMLDivElement | null>()\n\n  const translateX = anchorRect?.left ?? 0\n  const translateY = anchorRect?.top ?? 0\n  const width = anchorRect?.width ?? 0\n  const height = anchorRect?.height ?? 0\n\n  const boundingBox = React.useMemo(() => {\n    const box = {\n      x: translateY,\n      y: translateX,\n      top: translateY,\n      left: translateX,\n      bottom: translateY + width,\n      right: translateX + height,\n      width: width,\n      height: height,\n      toJSON: () => ({} as DOMRect),\n    }\n\n    box.toJSON = () => box\n\n    return box\n  }, [height, translateX, translateY, width])\n\n  const anchorEl = React.useMemo(\n    () => ({\n      getBoundingClientRect() {\n        return boundingBox\n      },\n    }),\n    [boundingBox]\n  )\n\n  // const isScrolling = useIsScrolling(200)\n\n  const anchorFit = useAnchor({\n    show: !!focusedDatum,\n    portalEl,\n    anchorEl,\n    tooltipEl,\n    side: ['right', 'left', 'top', 'bottom'],\n  })\n\n  const { visibility, ...anchorFitStyle } = anchorFit.style\n\n  const previousFocusedDatum = usePrevious(focusedDatum)\n  const previousAnchorFitStyle = usePrevious(anchorFitStyle)\n  const wasZero =\n    previousAnchorFitStyle?.left === 0 && previousAnchorFitStyle?.top === 0\n\n  const springProps = useSpring({\n    ...anchorFitStyle,\n    opacity: wasZero ? 0 : focusedDatum && anchorFit.fit ? 1 : 0,\n    config: { mass: 1, tension: 210, friction: 30 },\n    immediate: key => {\n      return (\n        // isScrolling ||\n        wasZero ||\n        (['left', 'top'].includes(key) &&\n          !previousFocusedDatum &&\n          !!focusedDatum)\n      )\n    },\n  })\n\n  const show = !!preTooltipOptions\n\n  return show && portalEl\n    ? ReactDOM.createPortal(\n        <animated.div style={springProps}>\n          <div\n            ref={el => setTooltipEl(el)}\n            style={{\n              fontFamily: 'sans-serif',\n              ...(anchorFit.fit?.startKey === 'left'\n                ? {\n                    padding: '0 10px',\n                  }\n                : {\n                    padding: '10px 0',\n                  }),\n            }}\n          >\n            {tooltipOptions.render({\n              getOptions,\n              focusedDatum: latestFocusedDatum,\n              primaryAxis,\n              secondaryAxis,\n              getDatumStyle: (datum: Datum<TDatum>) =>\n                getDatumStatusStyle(datum, focusedDatum),\n              anchorFit,\n            })}\n          </div>\n        </animated.div>,\n        portalEl\n      )\n    : null\n}\n","import React from 'react'\n\n//\nimport { Datum } from '../types'\nimport { translate } from '../utils/Utils'\nimport useChartContext from '../utils/chartContext'\n\nexport default function Voronoi<TDatum>() {\n  const { getOptions, useFocusedDatumAtom } = useChartContext<TDatum>()\n\n  const [, setFocusedDatum] = useFocusedDatumAtom()\n\n  const {\n    onFocusDatum,\n    onClickDatum,\n    tooltip,\n    primaryCursor,\n    secondaryCursor,\n    showVoronoi,\n    groupingMode,\n  } = getOptions()\n\n  const handleFocus = React.useCallback(\n    (datum: Datum<TDatum> | null) => {\n      onFocusDatum?.(datum)\n      setFocusedDatum(datum)\n    },\n    [onFocusDatum, setFocusedDatum]\n  )\n\n  const needsVoronoi =\n    onFocusDatum ||\n    onClickDatum ||\n    tooltip ||\n    primaryCursor ||\n    secondaryCursor ||\n    showVoronoi\n\n  // Don't render until we have all dependencies\n  if (!needsVoronoi) {\n    return null\n  }\n\n  const props = {\n    handleFocus,\n  }\n\n  if (groupingMode === 'primary') {\n    return <PrimaryVoronoi {...props} />\n  }\n\n  return null\n\n  // return <ClosestVoronoi {...props} />\n}\n\nfunction PrimaryVoronoi<TDatum>({\n  handleFocus,\n}: {\n  handleFocus: (datum: Datum<TDatum> | null) => void\n}) {\n  const {\n    primaryAxis,\n    series,\n    secondaryAxes,\n    getOptions,\n    gridDimensions,\n    groupedDatums,\n  } = useChartContext<TDatum>()\n\n  return React.useMemo(() => {\n    const columns = series[0].datums.map((datum, i) => {\n      const prev = series[0].datums[i - 1]\n      const next = series[0].datums[i + 1]\n\n      const primaryValue = primaryAxis.getValue(datum.originalDatum)\n      const primaryPx = primaryAxis?.scale(primaryValue) ?? NaN\n\n      let range = primaryAxis?.scale.range() ?? [0, 0]\n\n      if (primaryAxis?.isVertical) {\n        range.reverse()\n      }\n\n      let [primaryStart, primaryEnd] = range\n\n      if (prev) {\n        const prevPx =\n          primaryAxis?.scale(primaryAxis.getValue(prev.originalDatum)) ?? NaN\n        primaryStart = primaryPx - (primaryPx - prevPx) / 2\n      }\n\n      if (next) {\n        const nextPx =\n          primaryAxis?.scale(primaryAxis.getValue(next.originalDatum)) ?? NaN\n        primaryEnd = primaryPx + (nextPx - primaryPx) / 2\n      }\n\n      const datums = groupedDatums.get(`${primaryValue}`) ?? []\n\n      datums.sort((a, b) => {\n        const aAxis = secondaryAxes.find(d => d.id === a.secondaryAxisId)\n        const bAxis = secondaryAxes.find(d => d.id === b.secondaryAxisId)\n\n        const aPx =\n          aAxis?.scale(\n            aAxis.stacked ? a.stackData?.[1] : aAxis?.getValue(a.originalDatum)\n          ) ?? NaN\n        const bPx =\n          bAxis?.scale(\n            bAxis.stacked ? b.stackData?.[1] : bAxis?.getValue(b.originalDatum)\n          ) ?? NaN\n\n        return aPx - bPx\n      })\n\n      return {\n        primaryStart,\n        primaryEnd,\n        primaryPx,\n        datumBoundaries: datums.map((datum, i) => {\n          const prev = datums[i - 1]\n          const next = datums[i + 1]\n\n          const secondaryAxis = secondaryAxes.find(\n            d => d.id === datum.secondaryAxisId\n          )\n\n          if (secondaryAxis?.stacked) {\n            let range = secondaryAxis?.scale.range() ?? [0, 0]\n\n            if (secondaryAxis?.isVertical) {\n              range.reverse()\n            }\n\n            let [secondaryStart, secondaryEnd] = range\n\n            if (prev) {\n              secondaryStart =\n                secondaryAxis?.scale(datum.stackData?.[1] ?? NaN) ?? NaN\n            }\n\n            if (next) {\n              secondaryEnd =\n                secondaryAxis?.scale(datum.stackData?.[0] ?? NaN) ?? NaN\n            }\n\n            return {\n              secondaryStart,\n              secondaryEnd,\n              datum,\n            }\n          }\n\n          const value =\n            secondaryAxis?.scale(\n              secondaryAxis?.getValue(datum.originalDatum)\n            ) ?? NaN\n\n          let range = secondaryAxis?.scale.range() ?? [0, 0]\n\n          if (secondaryAxis?.isVertical) {\n            range.reverse()\n          }\n\n          let [secondaryStart, secondaryEnd] = range\n\n          if (prev) {\n            const prevAxis = secondaryAxes.find(\n              d => d.id === prev?.secondaryAxisId\n            )\n            const prevValue =\n              prevAxis?.scale(prevAxis?.getValue(prev.originalDatum)) ?? NaN\n            secondaryStart = value - (value - prevValue) / 2\n          }\n\n          if (next) {\n            const nextAxis = secondaryAxes.find(\n              d => d.id === next?.secondaryAxisId\n            )\n            const nextValue =\n              nextAxis?.scale(nextAxis?.getValue(next.originalDatum)) ?? NaN\n            secondaryEnd = value + (nextValue - value) / 2\n          }\n\n          return {\n            secondaryStart,\n            secondaryEnd,\n            datum,\n          }\n        }),\n      }\n    })\n\n    return (\n      <g\n        {...{\n          onMouseLeave: () => handleFocus(null),\n          style: {\n            transform: translate(gridDimensions.gridX, gridDimensions.gridY),\n          },\n        }}\n      >\n        {columns.map(column => {\n          return (\n            <React.Fragment key={column.primaryPx}>\n              {column.datumBoundaries.map(datumBoundary => {\n                const x1 = !primaryAxis.isVertical\n                  ? column.primaryStart\n                  : datumBoundary.secondaryStart\n                const x2 = !primaryAxis.isVertical\n                  ? column.primaryEnd\n                  : datumBoundary.secondaryEnd\n                const y1 = !primaryAxis.isVertical\n                  ? datumBoundary.secondaryStart\n                  : column.primaryStart\n                const y2 = !primaryAxis.isVertical\n                  ? datumBoundary.secondaryEnd\n                  : column.primaryEnd\n\n                const x = Math.min(x1, x2)\n                const y = Math.min(y1, y2)\n                const xEnd = Math.max(x1, x2)\n                const yEnd = Math.max(y1, y2)\n\n                const height = Math.max(yEnd - y, 0)\n                const width = Math.max(xEnd - x, 0)\n\n                return (\n                  <rect\n                    {...{\n                      key: `${column.primaryPx}_${datumBoundary.datum.seriesIndex}`,\n                      x,\n                      y,\n                      width,\n                      height,\n                      className: 'action-voronoi',\n                      onMouseEnter: () => handleFocus(datumBoundary.datum),\n                      style: {\n                        fill: randomFill(),\n                        opacity: getOptions().showVoronoi ? 1 : 0,\n                      },\n                    }}\n                  />\n                )\n              })}\n            </React.Fragment>\n          )\n        })}\n      </g>\n    )\n  }, [\n    getOptions,\n    gridDimensions.gridX,\n    gridDimensions.gridY,\n    groupedDatums,\n    handleFocus,\n    primaryAxis,\n    secondaryAxes,\n    series,\n  ])\n}\n\n// function ClosestVoronoi({\n//   stackData,\n//   extent,\n//   handleFocus,\n//   showVoronoi,\n// }: {\n//   stackData: Series[]\n//   extent: number[][]\n//   handleFocus: (datum: Datum | null) => void\n//   showVoronoi: boolean\n// }) {\n//   let polygons = null\n\n//   const voronoiData: { x: number; y: number; datum: Datum }[] = []\n\n//   stackData.forEach(series => {\n//     series.datums\n//       .filter(d => d.defined)\n//       .forEach(datum => {\n//         datum.boundingPoints.forEach(boundingPoint => {\n//           if (\n//             typeof datum.x !== 'number' ||\n//             typeof datum.y !== 'number' ||\n//             Number.isNaN(datum.y) ||\n//             Number.isNaN(datum.x)\n//           ) {\n//             return\n//           }\n//           voronoiData.push({\n//             x: boundingPoint.x,\n//             y: boundingPoint.y,\n//             datum,\n//           })\n//         })\n//       })\n//   })\n\n//   const delaunay = Delaunay.from(\n//     voronoiData,\n//     d => Math.max(d.x, 0),\n//     d => Math.max(d.y, 0)\n//   )\n\n//   const flatExtent = extent.flat().map(d => Math.max(d, 0))\n\n//   const voronoi = delaunay.voronoi(flatExtent)\n\n//   polygons = voronoi.cellPolygons()\n\n//   polygons = Array.from(polygons)\n\n//   return (\n//     <g>\n//       {polygons.map((points, i) => {\n//         const index = points.index\n//         const datum = voronoiData[index].datum\n//         const path = lineFn(points as any) || undefined\n//         return (\n//           <Path\n//             key={i}\n//             d={path}\n//             className=\"action-voronoi\"\n//             onMouseEnter={() => handleFocus(datum)}\n//             onMouseLeave={() => handleFocus(null)}\n//             style={{\n//               fill: randomFill(),\n//               opacity: showVoronoi ? 1 : 0,\n//             }}\n//           />\n//         )\n//       })}\n//     </g>\n//   )\n// }\n\nfunction randomFill() {\n  const r = randomHue(100, 200)\n  const g = randomHue(0, r)\n  const b = randomHue(0, g)\n\n  const colors = shuffle([r, g, b])\n\n  return `rgba(${colors.join(', ')}, .5)`\n}\n\nfunction randomHue(min = 0, max = 255) {\n  return Math.floor(min + Math.random() * Math.min(max, 255 - min))\n}\n\nfunction shuffle<T>(array: T[]): T[] {\n  var currentIndex = array.length,\n    randomIndex\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex)\n    currentIndex--\n\n    // And swap it with the current element.\n    ;[array[currentIndex], array[randomIndex]] = [\n      array[randomIndex],\n      array[currentIndex],\n    ]\n  }\n\n  return array\n}\n","import { groups, sort } from 'd3-array'\nimport { stack, stackOffsetNone } from 'd3-shape'\nimport { atom, useAtom } from 'jotai'\nimport React, { ComponentPropsWithoutRef } from 'react'\n\nimport useGetLatest from '../hooks/useGetLatest'\nimport useIsomorphicLayoutEffect from '../hooks/useIsomorphicLayoutEffect'\nimport useRect from '../hooks/useRect'\nimport Area from '../seriesTypes/Area'\nimport Bar from '../seriesTypes/Bar'\nimport Line from '../seriesTypes/Line'\n//\nimport {\n  AxesInfo,\n  AxisDimension,\n  AxisDimensions,\n  ChartContextValue,\n  ChartOptions,\n  Datum,\n  GridDimensions,\n  Measurement,\n  RequiredChartOptions,\n  Series,\n  StackDatum,\n} from '../types'\nimport {\n  materializeStyles,\n  getSeriesStatus,\n  getDatumStatus,\n} from '../utils/Utils'\nimport buildAxisLinear from '../utils/buildAxis.linear'\nimport { ChartContextProvider } from '../utils/chartContext'\nimport AxisLinear from './AxisLinear'\n// import Brush from './Brush'\nimport Cursors from './Cursors'\nimport Tooltip from './Tooltip'\nimport Voronoi from './Voronoi'\n\n//\n\n//\n\nconst defaultColorScheme = [\n  '#0f83ab',\n  '#faa43a',\n  '#ff4e4e',\n  '#53cfc9',\n  '#a2d925',\n  '#decf3f',\n  '#734fe9',\n  '#cd82ad',\n  '#006d92',\n  '#de7c00',\n  '#f33232',\n  '#3f9a80',\n  '#53c200',\n  '#d7af00',\n  '#4c26c9',\n  '#d44d99',\n]\n\nfunction defaultChartOptions<TDatum>(\n  options: ChartOptions<TDatum>\n): RequiredChartOptions<TDatum> {\n  return {\n    ...options,\n    initialWidth: options.initialWidth ?? 300,\n    initialHeight: options.initialHeight ?? 200,\n    getSeriesStyle: options.getSeriesStyle ?? (() => ({})),\n    getDatumStyle: options.getDatumStyle ?? (() => ({})),\n    getSeriesOrder:\n      options.getSeriesOrder ?? ((series: Series<TDatum>[]) => series),\n    groupingMode: options.groupingMode ?? 'primary',\n    showVoronoi: options.showVoronoi ?? false,\n    defaultColors: options.defaultColors ?? defaultColorScheme,\n  }\n}\n\nexport function Chart<TDatum>({\n  options: userOptions,\n  className,\n  style = {},\n  ...rest\n}: ComponentPropsWithoutRef<'div'> & { options: ChartOptions<TDatum> }) {\n  const options = defaultChartOptions(userOptions)\n  const [\n    containerElement,\n    setContainerElement,\n  ] = React.useState<HTMLDivElement | null>(null)\n  const parentElement = containerElement?.parentElement\n\n  const { width, height } = useRect(parentElement, options)\n\n  useIsomorphicLayoutEffect(() => {\n    if (parentElement) {\n      const computed = window.getComputedStyle(parentElement)\n\n      if (!['relative', 'absolute', 'fixed'].includes(computed.display)) {\n        parentElement.style.position = 'relative'\n      }\n    }\n  }, [parentElement])\n\n  return (\n    <div\n      ref={setContainerElement}\n      {...rest}\n      className={`ReactChart ${className || ''}`}\n      style={{\n        ...style,\n        position: 'absolute',\n        width,\n        height,\n      }}\n    >\n      <ChartInner options={options} {...{ width, height }} />\n    </div>\n  )\n}\n\nfunction ChartInner<TDatum>({\n  options,\n  width,\n  height,\n}: {\n  options: RequiredChartOptions<TDatum>\n  width: number\n  height: number\n}) {\n  if (!options.primaryAxis) {\n    throw new Error('A primaryAxis is required')\n  }\n\n  if (!options.secondaryAxes.length) {\n    throw new Error('At least one secondaryAxis is required')\n  }\n\n  const svgRef = React.useRef<SVGSVGElement>(null)\n  const svgRect = useRect(svgRef.current)\n  const getOptions = useGetLatest(options)\n\n  const axisDimensionsAtom = React.useMemo(\n    () =>\n      atom<AxisDimensions>({\n        left: {},\n        right: {},\n        top: {},\n        bottom: {},\n      }),\n    []\n  )\n\n  const focusedDatumAtom = React.useMemo(\n    () => atom<Datum<TDatum> | null>(null),\n    []\n  )\n\n  const useAxisDimensionsAtom = React.useCallback(() => {\n    // eslint-disable-next-line\n    return useAtom(axisDimensionsAtom)\n  }, [axisDimensionsAtom])\n  const useFocusedDatumAtom = React.useCallback(() => {\n    // eslint-disable-next-line\n    return useAtom(focusedDatumAtom)\n  }, [focusedDatumAtom])\n\n  // useAtom<Datum<TDatum> | null>(focusedDatumAtom)\n\n  const [axisDimensions] = useAxisDimensionsAtom()\n  const [focusedDatum] = useFocusedDatumAtom()\n\n  const gridDimensions = React.useMemo((): GridDimensions => {\n    // Left\n    const [axesLeftWidth, axesLeftTop, axesLeftBottom] = ([\n      'width',\n      'top',\n      'bottom',\n    ] as Measurement[]).map(prop =>\n      sumAllDimensionProperties(axisDimensions.left, prop)\n    )\n\n    const [axesRightWidth, axesRightTop, axesRightBottom] = ([\n      'width',\n      'top',\n      'bottom',\n    ] as Measurement[]).map(prop =>\n      sumAllDimensionProperties(axisDimensions.right, prop)\n    )\n\n    const [axesTopHeight, axesTopLeft, axesTopRight] = ([\n      'height',\n      'left',\n      'right',\n    ] as Measurement[]).map(prop =>\n      sumAllDimensionProperties(axisDimensions.top, prop)\n    )\n\n    const [axesBottomHeight, axesBottomLeft, axesBottomRight] = ([\n      'height',\n      'left',\n      'right',\n    ] as Measurement[]).map(prop =>\n      sumAllDimensionProperties(axisDimensions.bottom, prop)\n    )\n\n    const gridX = Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft)\n    const gridY = Math.max(axesTopHeight, axesLeftTop, axesRightTop)\n    const gridWidth = Math.max(\n      0,\n      width -\n        Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) -\n        Math.max(axesRightWidth, axesTopRight, axesBottomRight)\n    )\n    const gridHeight = Math.max(\n      0,\n      height -\n        Math.max(axesTopHeight, axesLeftTop, axesRightTop) -\n        Math.max(axesBottomHeight, axesLeftBottom, axesRightBottom)\n    )\n\n    return { gridX, gridY, gridWidth, gridHeight }\n  }, [width, height, axisDimensions])\n\n  const series = React.useMemo(() => {\n    const series: Series<TDatum>[] = []\n\n    for (\n      let seriesIndex = 0;\n      seriesIndex < options.data.length;\n      seriesIndex++\n    ) {\n      const originalSeries = options.data[seriesIndex]\n      const seriesId = originalSeries.id ?? seriesIndex + ''\n      const seriesLabel = originalSeries.label ?? `Series ${seriesIndex + 1}`\n      const secondaryAxisId = originalSeries.secondaryAxisId\n      const originalDatums = originalSeries.data\n      const datums = []\n\n      for (\n        let datumIndex = 0;\n        datumIndex < originalDatums.length;\n        datumIndex++\n      ) {\n        const originalDatum = originalDatums[datumIndex]\n        datums[datumIndex] = {\n          originalSeries,\n          seriesIndex,\n          seriesId,\n          seriesLabel,\n          secondaryAxisId,\n          index: datumIndex,\n          originalDatum,\n        }\n      }\n\n      series[seriesIndex] = {\n        originalSeries,\n        index: seriesIndex,\n        id: seriesId,\n        label: seriesLabel,\n        secondaryAxisId,\n        datums,\n      }\n    }\n\n    if (options.secondaryAxes.some(axisOptions => axisOptions.stacked)) {\n      options.secondaryAxes\n        .filter(d => d.stacked)\n        .forEach(secondaryAxis => {\n          const axisSeries = series.filter(\n            s => s.secondaryAxisId === secondaryAxis.id\n          )\n          const seriesIndices = Object.keys(axisSeries)\n          const stacker = stack()\n            .keys(seriesIndices)\n            .value((_, seriesIndex, index) => {\n              const val = secondaryAxis.getValue(\n                axisSeries[Number(seriesIndex)].datums[index].originalDatum\n              )\n\n              if (typeof val === 'undefined' || val === null) {\n                return 0\n              }\n\n              return val\n            })\n            .offset(secondaryAxis.stackOffset ?? stackOffsetNone)\n\n          const stacked = stacker(\n            Array.from({\n              length: axisSeries.sort(\n                (a, b) => b.datums.length - a.datums.length\n              )[0].datums.length,\n            })\n          )\n\n          stacked.forEach((s, sIndex) => {\n            s.forEach((datum, i) => {\n              // @ts-ignore\n              datum.data = axisSeries[sIndex].datums[i]\n\n              axisSeries[sIndex].datums[\n                i\n              ].stackData = (datum as unknown) as StackDatum<TDatum>\n            })\n          })\n        })\n    }\n\n    return series\n  }, [options.data, options.secondaryAxes])\n\n  const primaryAxis = React.useMemo(() => {\n    return buildAxisLinear<TDatum>(\n      options.primaryAxis,\n      series,\n      gridDimensions,\n      width,\n      height\n    )\n  }, [gridDimensions, height, options.primaryAxis, series, width])\n\n  const secondaryAxes = React.useMemo(() => {\n    return options.secondaryAxes.map(secondaryAxis => {\n      return buildAxisLinear<TDatum>(\n        secondaryAxis,\n        series,\n        gridDimensions,\n        width,\n        height\n      )\n    })\n  }, [gridDimensions, height, options.secondaryAxes, series, width])\n\n  const axesInfo: AxesInfo = React.useMemo(() => {\n    // Make sure we're mapping x and y to the correct axes\n    const xKey = primaryAxis.isVertical ? 'secondary' : 'primary'\n    const yKey = primaryAxis.isVertical ? 'primary' : 'secondary'\n\n    return {\n      xKey,\n      yKey,\n    }\n  }, [primaryAxis])\n\n  const groupedDatums = React.useMemo(() => {\n    const groupedDatums = new Map<any, Datum<TDatum>[]>()\n\n    const allDatums = series.map(s => s.datums).flat(2)\n\n    allDatums.forEach(datum => {\n      const primaryValue = `${primaryAxis.getValue(datum.originalDatum)}`\n\n      if (!groupedDatums.has(primaryValue)) {\n        groupedDatums.set(primaryValue, [])\n      }\n\n      groupedDatums.get(primaryValue)!.push(datum)\n    })\n\n    allDatums.forEach(datum => {\n      const primaryValue = `${primaryAxis.getValue(datum.originalDatum)}`\n\n      datum.group = groupedDatums.get(primaryValue)\n    })\n\n    return groupedDatums\n  }, [primaryAxis, series])\n\n  const getSeriesStatusStyle = React.useCallback(\n    (series: Series<TDatum>, focusedDatum: Datum<TDatum> | null) => {\n      const base = {\n        color: getOptions().defaultColors[\n          series.index % (getOptions().defaultColors.length - 1)\n        ],\n      }\n\n      const status = getSeriesStatus(series, focusedDatum)\n      const statusStyles = getOptions().getSeriesStyle(series, status)\n      series.style = materializeStyles(statusStyles, base)\n      return series.style\n    },\n    [getOptions]\n  )\n\n  const getDatumStatusStyle = React.useCallback(\n    (datum: Datum<TDatum>, focusedDatum: Datum<TDatum> | null) => {\n      const base = {\n        ...series[datum.seriesIndex].style,\n        color: getOptions().defaultColors[\n          datum.seriesIndex % (getOptions().defaultColors.length - 1)\n        ],\n      }\n\n      const status = getDatumStatus(datum as Datum<TDatum>, focusedDatum)\n      const statusStyles = getOptions().getDatumStyle(\n        datum as Datum<TDatum>,\n        status\n      )\n\n      datum.style = materializeStyles(statusStyles, base)\n\n      return datum.style\n    },\n    [getOptions, series]\n  )\n\n  // const mouseMoveRafRef = React.useRef<number | null>()\n\n  // const onMouseMove = (\n  //   e: React.MouseEvent<SVGSVGElement, MouseEvent> | MouseEvent\n  // ) => {\n  //   if (mouseMoveRafRef.current) {\n  //     Raf.cancel(mouseMoveRafRef.current)\n  //   }\n\n  //   mouseMoveRafRef.current = Raf(() => {\n  //     mouseMoveRafRef.current = null\n  //     const { clientX, clientY } = e\n\n  //     setPointer(old => {\n  //       const x = clientX - svgRect.left - gridDimensions.gridX\n  //       const y = clientY - svgRect.top - gridDimensions.gridY\n\n  //       return {\n  //         ...old,\n  //         svgHovered: true,\n  //         x,\n  //         y,\n  //       }\n  //     })\n  //   })\n  // }\n\n  // const onMouseUp = () => {\n  //   document.removeEventListener('mouseup', onMouseUp)\n  //   document.removeEventListener('mousemove', onMouseMove)\n\n  //   // if (options.brush?.onSelect && pointer.dragging) {\n  //   //   if (Math.abs(pointer.startX - pointer.x) >= 20) {\n  //   //     options.brush.onSelect({\n  //   //       pointer,\n  //   //       start: (axesInfo.primaryAxes[0].scale as ScaleLinear<\n  //   //         number,\n  //   //         number\n  //   //       >).invert(pointer.startX),\n  //   //       end: (axesInfo.primaryAxes[0].scale as ScaleLinear<\n  //   //         number,\n  //   //         number\n  //   //       >).invert(pointer.x),\n  //   //     })\n  //   //   }\n  //   // }\n\n  //   setPointer(\n  //     (old): Pointer => {\n  //       return {\n  //         ...old,\n  //         dragging: false,\n  //       }\n  //     }\n  //   )\n  // }\n\n  // const onMouseDown = () => {\n  //   document.addEventListener('mouseup', onMouseUp)\n  //   document.addEventListener('mousemove', onMouseMove)\n\n  //   setPointer(\n  //     (old): Pointer => {\n  //       return {\n  //         ...old,\n  //         startX: old.x,\n  //         startY: old.y,\n  //         dragging: true,\n  //       }\n  //     }\n  //   )\n  // }\n\n  // Reverse the stack order for proper z-indexing\n  const reversedSeries = [...series].reverse()\n  let orderedSeries = options.getSeriesOrder(reversedSeries)\n\n  // const focusedSeriesIndex = focusedDatum\n  //   ? orderedSeries.findIndex(series => series.id === focusedDatum.seriesId)\n  //   : -1\n\n  // Bring focused series to the front\n  // orderedSeries = focusedDatum\n  //   ? [\n  //       ...orderedSeries.slice(0, focusedSeriesIndex),\n  //       ...orderedSeries.slice(focusedSeriesIndex + 1),\n  //       orderedSeries[focusedSeriesIndex],\n  //     ]\n  //   : orderedSeries\n\n  useIsomorphicLayoutEffect(() => {\n    if (\n      svgRef.current &&\n      svgRef.current.parentElement &&\n      !svgRef.current.parentElement.style.position\n    ) {\n      svgRef.current.parentElement.style.position = 'relative'\n    }\n  })\n\n  const contextValue: ChartContextValue<TDatum> = {\n    getOptions,\n    gridDimensions,\n    primaryAxis,\n    secondaryAxes,\n    axesInfo,\n    series,\n    orderedSeries,\n    groupedDatums,\n    width,\n    height,\n    getSeriesStatusStyle,\n    getDatumStatusStyle,\n    useAxisDimensionsAtom,\n    useFocusedDatumAtom,\n    svgRect,\n  }\n\n  const seriesByAxisId = sort(\n    groups(orderedSeries, d => d.secondaryAxisId),\n    ([key]) => secondaryAxes.findIndex(axis => axis.id === key)\n  )\n\n  return (\n    <ChartContextProvider value={useGetLatest(contextValue)}>\n      <div\n        style={{\n          fontFamily: 'sans-serif',\n        }}\n      >\n        <svg\n          ref={svgRef}\n          style={{\n            width,\n            height,\n            overflow: options.brush ? 'hidden' : 'visible',\n          }}\n          // onMouseEnter={e => {\n          //   e.persist()\n          //   onMouseMove(e)\n          // }}\n          // onMouseMove={e => {\n          //   e.persist()\n          //   onMouseMove(e)\n          // }}\n          // onMouseLeave={e => {\n          //   e.persist()\n          //   setPointer(old => {\n          //     return {\n          //       ...old,\n          //       svgHovered: false,\n          //     }\n          //   })\n          // }}\n          // onMouseDown={e => {\n          //   e.persist()\n          //   onMouseDown()\n          // }}\n          onClick={e => options.onClickDatum?.(focusedDatum, e)}\n        >\n          <g\n            className=\"Series\"\n            style={{\n              pointerEvents: 'none',\n            }}\n          >\n            {seriesByAxisId.map(([axisId, series]) => {\n              const secondaryAxis = secondaryAxes.find(d => d.id === axisId)\n\n              if (!secondaryAxis) {\n                return null\n              }\n\n              const { elementType } = secondaryAxis\n              const Component = (() => {\n                if (elementType === 'line') {\n                  return Line\n                }\n                if (elementType === 'bar') {\n                  return Bar\n                }\n                if (elementType === 'area') {\n                  return Area\n                }\n                throw new Error('Invalid elementType')\n              })()\n\n              return (\n                <Component\n                  key={axisId ?? '__default__'}\n                  primaryAxis={primaryAxis}\n                  secondaryAxis={secondaryAxis}\n                  series={series}\n                />\n              )\n            })}\n          </g>\n          <g className=\"axes\">\n            {[primaryAxis, ...secondaryAxes].map(axis => (\n              <AxisLinear key={[axis.position, axis.id].join('')} {...axis} />\n            ))}\n          </g>\n          <Voronoi />\n          {options.renderSVG?.() ?? null}\n        </svg>\n        <Cursors />\n        <Tooltip />\n      </div>\n    </ChartContextProvider>\n  )\n}\n\nfunction sumAllDimensionProperties(\n  axisDimensions: Record<string, AxisDimension>,\n  side: Measurement\n) {\n  let sum = 0\n\n  Object.keys(axisDimensions).forEach(axisId => {\n    sum += axisDimensions[axisId]?.[side] || 0\n  })\n\n  return sum\n}\n"],"names":["useGetLatest","obj","ref","React","useRef","getterRef","current","window","useLayoutEffect","useEffect","useRect","node","options","enabled","useState","element","setElement","width","initialWidth","height","initialHeight","rect","setRect","useIsomorphicLayoutEffect","initialRectSet","getBoundingClientRect","observer","observeRect","observe","unobserve","elementTypes","materializeStyles","style","defaults","stroke","color","fill","normalizeColor","i","length","type","translate","x","y","Math","round","getSecondaries","datum","secondaryAxis","stacked","scale","stackData","_datum$stackData","NaN","_datum$stackData2","getValue","originalDatum","getPrimary","primaryAxis","primary","_datum$stackData4","invert","axisFamily","getPrimaryLength","_datum","min","max","bandwidth","minBandSize","maxBandSize","bandScale","getSecondaryLength","secondary","sort","abs","getX","isVertical","getY","getWidth","getHeight","chartContext","ChartContextProvider","Provider","value","children","useChartContext","sign","slope3","that","x2","y2","h0","_x1","_x0","h1","s0","_y1","_y0","s1","p","slope2","t","h","point","t0","t1","x0","x1","y1","dx","_context","bezierCurveTo","MonotoneX","context","ReflectContext","prototype","areaStart","_line","areaEnd","lineStart","this","_t0","_point","lineEnd","lineTo","closePath","moveTo","Object","create","call","monotoneX","AreaComponent","allSeries","series","getSeriesStatusStyle","getDatumStatusStyle","gridDimensions","curve","focusedDatum","useFocusedDatumAtom","xAxis","yAxis","isEnd","transform","gridX","gridY","map","lineStyle","strokeWidth","line","areaStyle","opacity","area","areaPath","datums","undefined","linePath","key","d","dataStyle","el","r","cx","cy","circle","showDatumElements","BarComponent","rectangle","pathDefaultStyle","Line","buildAxisLinear","userOptions","elementType","minTickPaddingForRotation","tickLabelRotationDeg","innerBandPadding","outerBandPadding","show","defaultAxisOptions","position","Error","indexOf","range","gridHeight","gridWidth","outerRange","scaleType","scaleTime","scaleUtc","allDatums","flat","extent","minValue","maxValue","console","info","values","domain","hardMin","Number","hardMax","Array","from","reverse","nice","outerScale","copy","buildImpliedBandScale","defaultFormat","tickFormat","formatters","scaleFormat","_options$formatters","tooltipFormat","_options$formatters2","tooltip","assign","cursor","_options$formatters3","buildTimeAxis","scaleLog","scaleLinear","s","_options$formatters4","_options$formatters5","_options$formatters6","buildLinearAxis","Set","scaleBand","paddingOuter","paddingInner","_options$formatters7","_options$formatters8","_options$formatters9","buildBandAxis","impliedBandWidth","forEach","serie","d1","one","d2","two","diff","bandRange","bandDomain","d3Range","getElBox","top","right","bottom","left","AxisLinearComp","axis","showRotated","setShowRotated","getOptions","dark","showDebugAxes","elRef","useAxisDimensionsAtom","axisDimensions","setAxisDimensions","axisDimension","useMemo","_axisDimensions$axis$","id","measureRotation","useCallback","widestLabel","gridSize","staticLabelDims","querySelectorAll","label","resolvedLabel","smallestTickGap","prev","shouldRotate","measureDimensions","newDimensions","domainEl","querySelector","domainDims","measureDims","widestRealLabel","tallestRealLabel","topMostLabelDim","reduce","labelDim","bottomMostLabelDim","_widestRealLabel","leftMostLabelDim","rightMostLabelDim","_tallestRealLabel","keys","some","old","newAxes","useMeasure","renderAxis","isOuter","isRotated","rangeStart","rangeEnd","resolvedHeight","resolvedWidth","lineFrom","className","pointerEvents","num","ticks","getTicks","tick","px","getTickPx","tickFrom","tickTo","gridTo","tickLabelX","tickLabelY","showGrid","fontSize","dominantBaseline","textAnchor","useLatestWhen","when","usePortalElement","portalEl","setPortalEl","document","getElementById","createElement","setAttribute","body","append","getBackgroundColor","defaultCursor","showLine","showLabel","Cursors","primaryOptions","primaryCursor","secondaryOptions","secondaryCursor","resolvedPrimaryOptions","resolvedSecondaryOptions","Cursor","props","alignPctX","alignPctY","svgRect","secondaryAxes","latestFocusedDatum","find","axisId","secondaryAxisId","siblingAxis","resolveValue","_d$stackData","latestValue","siblingRange","bandWidth","isNaN","bubbleX","bubbleY","lineStartX","lineStartY","lineEndX","lineEndY","lineHeight","lineWidth","formattedValue","lineSpring","useSpring","config","stiff","bubbleSpring","ReactDOM","createPortal","transition","animated","div","background","padding","borderRadius","whiteSpace","sideSchemas","side","startKey","lengthKey","crossStartKey","crossLengthKey","fromEnd","usePrevious","val","TooltipRenderer","getDatumStyle","groupingMode","groupDatums","_props$focusedDatum","group","activeIndex","findIndex","start","resolvedShowCount","end","arrowPosition","triangleStyles","visibleSortedGroupDatums","slice","hasPrevious","hasNext","finalAlign","anchorFit","fit","_props$anchorFit$fit","_props$anchorFit$fit2","align","backgroundColor","borderLeft","borderRight","borderTop","triangleSize","borderBottom","marginBottom","textAlign","seriesLabel","sortedDatum","active","fontWeight","display","alignItems","justifyContent","Fragment","paddingTop","sum","Tooltip","preTooltipOptions","tooltipOptions","alignPriority","tooltipArrowPadding","render","anchorRect","_latestFocusedDatum$e2","portalDims","anchorDims","tooltipDims","sides","ready","tooltipEl","setTooltipEl","translateX","_anchorRect","translateY","_anchorRect2","_anchorRect3","_anchorRect4","boundingBox","box","toJSON","anchorEl","isArray","alignStr","split","JSON","stringify","useLargest","fits","targetStart","fitRatio","crossTargetStart","parentStart","parentLength","crossParentStart","crossParentLength","anchorStart","anchorLength","crossAnchorStart","crossAnchorLength","crossAnchorWidth","targetLength","crossTargetLength","includes","measureFit","a","b","fitOnBestSide","visibility","anchorFitStyle","previousFocusedDatum","previousAnchorFitStyle","wasZero","springProps","mass","tension","friction","immediate","fontFamily","Voronoi","setFocusedDatum","onFocusDatum","onClickDatum","showVoronoi","handleFocus","PrimaryVoronoi","groupedDatums","columns","next","primaryValue","primaryPx","primaryStart","primaryEnd","get","aAxis","bAxis","_a$stackData","_b$stackData","datumBoundaries","secondaryStart","secondaryEnd","prevAxis","nextAxis","onMouseLeave","column","datumBoundary","g","colors","xEnd","yEnd","seriesIndex","onMouseEnter","randomHue","shuffle","join","floor","random","array","randomIndex","currentIndex","defaultColorScheme","ChartInner","svgRef","axisDimensionsAtom","atom","focusedDatumAtom","useAtom","prop","sumAllDimensionProperties","axesLeftWidth","axesLeftTop","axesLeftBottom","axesRightWidth","axesRightTop","axesRightBottom","axesTopHeight","axesTopLeft","axesTopRight","axesBottomHeight","axesBottomLeft","axesBottomRight","data","originalSeries","seriesId","originalDatums","datumIndex","index","axisOptions","filter","axisSeries","seriesIndices","stack","_","offset","stackOffset","stackOffsetNone","stacker","sIndex","axesInfo","xKey","yKey","Map","has","set","push","base","defaultColors","status","getSeriesStatus","statusStyles","getSeriesStyle","_datum$group","groupDatum","getDatumStatus","reversedSeries","orderedSeries","getSeriesOrder","parentElement","contextValue","seriesByAxisId","groups","overflow","brush","onClick","e","Component","Bar","Area","AxisLinear","renderSVG","rest","defaultChartOptions","containerElement","setContainerElement","computed","getComputedStyle"],"mappings":"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"}