import { extent, range, sum, sort, groups } from 'd3-array';
import { area, line, stack, stackOffsetNone } from 'd3-shape';
import { atom, useAtom } from 'jotai';
import React__default, { useContext, createContext, createElement, useState } from 'react';
import observeRect from '@reach/observe-rect';
import { scaleLog, scaleLinear, scaleBand, scaleTime, scaleUtc } from 'd3-scale';
import ReactDOM from 'react-dom';
import { useSpring, config, animated } from '@react-spring/web';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function useGetLatest(obj) {
  var ref = React__default.useRef(obj);
  var getterRef = React__default.useRef();
  ref.current = obj;

  if (!getterRef.current) {
    getterRef.current = function () {
      return ref.current;
    };
  }

  return getterRef.current;
}

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__default.useLayoutEffect : React__default.useEffect;

function useRect(node, options) {
  var _options$enabled, _options$initialWidth, _options$initialHeigh;

  var enabled = (_options$enabled = options == null ? void 0 : options.enabled) != null ? _options$enabled : true;

  var _React$useState = React__default.useState(node),
      element = _React$useState[0],
      setElement = _React$useState[1];

  var _React$useState2 = React__default.useState({
    width: (_options$initialWidth = options == null ? void 0 : options.initialWidth) != null ? _options$initialWidth : 0,
    height: (_options$initialHeigh = options == null ? void 0 : options.initialHeight) != null ? _options$initialHeigh : 0
  }),
      rect = _React$useState2[0],
      setRect = _React$useState2[1];

  useIsomorphicLayoutEffect(function () {
    if (node !== element) {
      setElement(node);
    }
  });
  var initialRectSet = React__default.useRef(false);
  useIsomorphicLayoutEffect(function () {
    if (element && !initialRectSet.current) {
      initialRectSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]); // const isScrolling = useIsScrolling(200)

  React__default.useEffect(function () {
    if (!element || !enabled) {
      return;
    }

    var observer = observeRect(element, setRect);
    observer.observe();
    return function () {
      observer.unobserve();
    };
  }, [element, enabled]); // const resolvedRect = React.useMemo(() => {
  //   if (!element || !(element as Element).tagName) {
  //     return rect
  //   }
  //   const styles = window.getComputedStyle(element as Element)
  //   return {
  //     x: rect.x,
  //     y: rect.y,
  //     width:
  //       rect.width -
  //       parseInt(styles.borderLeftWidth) -
  //       parseInt(styles.borderRightWidth),
  //     height:
  //       rect.height -
  //       parseInt(styles.borderTopWidth) -
  //       parseInt(styles.borderBottomWidth),
  //     top: rect.top,
  //     right: rect.right,
  //     bottom: rect.bottom,
  //     left: rect.left,
  //   }
  // }, [element, rect])

  return rect;
}

function getSeriesStatus(series, focusedDatum) {
  if ((focusedDatum == null ? void 0 : focusedDatum.seriesId) === series.id) {
    return 'focused';
  }

  return 'none';
}
function getDatumStatus(datum, focusedDatum) {
  var _datum$group;

  if (datum === focusedDatum) {
    return 'focused';
  }

  if ((_datum$group = datum.group) != null && _datum$group.some(function (groupDatum) {
  })) {
    return 'groupFocused';
  }

  return 'none';
}

function normalizeColor(style, defaults) {
  return _extends({}, style, {
    stroke: style.stroke || style.color || defaults.stroke || defaults.color,
    fill: style.fill || style.color || defaults.fill || defaults.color
  });
}

var elementTypes = ['area', 'line', 'rectangle', 'circle'];
function materializeStyles(style, defaults) {
  if (style === void 0) {
    style = {};
  }

  if (defaults === void 0) {
    defaults = {};
  }

  style = normalizeColor(style, defaults);

  for (var i = 0; i < elementTypes.length; i++) {
    var type = elementTypes[i];

    if (style[type] && defaults[type]) {
      style[type] = materializeStyles(style[type], defaults);
    }
  }

  return style;
}
function translate(x, y) {
  return "translate3d(" + Math.round(x) + "px, " + Math.round(y) + "px, 0)";
}
function getSecondaries(datum, secondaryAxis) {
  var _secondaryAxis$scale3, _secondaryAxis$scale4;

  if (secondaryAxis.stacked) {
    var _secondaryAxis$scale, _datum$stackData$, _datum$stackData, _secondaryAxis$scale2, _datum$stackData$2, _datum$stackData2;

    return [(_secondaryAxis$scale = secondaryAxis.scale((_datum$stackData$ = (_datum$stackData = datum.stackData) == null ? void 0 : _datum$stackData[0]) != null ? _datum$stackData$ : NaN)) != null ? _secondaryAxis$scale : NaN, (_secondaryAxis$scale2 = secondaryAxis.scale((_datum$stackData$2 = (_datum$stackData2 = datum.stackData) == null ? void 0 : _datum$stackData2[1]) != null ? _datum$stackData$2 : NaN)) != null ? _secondaryAxis$scale2 : NaN];
  }

  return [(_secondaryAxis$scale3 = secondaryAxis.scale(0)) != null ? _secondaryAxis$scale3 : NaN, (_secondaryAxis$scale4 = secondaryAxis.scale(secondaryAxis.getValue(datum.originalDatum))) != null ? _secondaryAxis$scale4 : NaN];
}
function getPrimary(datum, primaryAxis) {
  var primary;

  if (primaryAxis.stacked) {
    var _primaryAxis$scale, _datum$stackData3, _datum$stackData4;

    primary = (_primaryAxis$scale = primaryAxis.scale((_datum$stackData3 = (_datum$stackData4 = datum.stackData) == null ? void 0 : _datum$stackData4[primaryAxis.invert ? 1 : 0]) != null ? _datum$stackData3 : NaN)) != null ? _primaryAxis$scale : NaN;
  } else {
    var _primaryAxis$scale2;

    primary = (_primaryAxis$scale2 = primaryAxis.scale(primaryAxis.getValue(datum.originalDatum))) != null ? _primaryAxis$scale2 : NaN;
  }

  if (primaryAxis.axisFamily !== 'band') {
    primary = primary - getPrimaryLength(datum, primaryAxis) / 2;
  }

  return primary;
}
function getPrimaryLength(_datum, primaryAxis) {
  if (primaryAxis.axisFamily === 'band') {
    var _primaryAxis$minBandS, _primaryAxis$maxBandS;

    return Math.min(Math.max(primaryAxis.scale.bandwidth(), (_primaryAxis$minBandS = primaryAxis.minBandSize) != null ? _primaryAxis$minBandS : 99999999), (_primaryAxis$maxBandS = primaryAxis.maxBandSize) != null ? _primaryAxis$maxBandS : 1);
  }

  return Math.max(primaryAxis.bandScale.bandwidth(), 1);
}
function getSecondaryLength(datum, secondaryAxis) {
  var secondary = getSecondaries(datum, secondaryAxis).sort();
  return Math.abs(secondary[1] - secondary[0]);
}
function getX(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getSecondaries(datum, secondaryAxis)[secondaryAxis.invert ? 1 : 0] : getPrimary(datum, primaryAxis);
}
function getY(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getPrimary(datum, primaryAxis) : getSecondaries(datum, secondaryAxis)[secondaryAxis.invert ? 1 : 0] - getSecondaryLength(datum, secondaryAxis);
}
function getWidth(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getSecondaryLength(datum, secondaryAxis) : getPrimaryLength(datum, primaryAxis);
}
function getHeight(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getPrimaryLength(datum, primaryAxis) : getSecondaryLength(datum, secondaryAxis);
}
function getTickPx(scale, value) {
  var _scale;

  var px = (_scale = scale(value)) != null ? _scale : NaN; // @ts-ignore

  if (scale.bandwidth) {
    // @ts-ignore
    return px + scale.bandwidth() / 2;
  }

  return px;
}

var chartContext = /*#__PURE__*/createContext(null);
function ChartContextProvider(_ref) {
  var value = _ref.value,
      children = _ref.children;
  return createElement(chartContext.Provider, {
    value: value,
    children: children
  });
}
function useChartContext() {
  return useContext(chartContext)();
}

function sign(x) {
  return x < 0 ? -1 : 1;
} // Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.


function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
} // Calculate a one-sided slope.


function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
} // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic BÃ©zier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".


function _point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;

  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;

      case 3:
        _point(this, this._t0, slope2(this, this._t0));

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    var t1 = NaN;
    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        _point(this, slope2(this, t1 = slope3(this, x, y)), t1);

        break;

      default:
        _point(this, this._t0, t1 = slope3(this, x, y));

        break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = /*#__PURE__*/Object.create(MonotoneX.prototype)).point = function (x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function moveTo(x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};
var monotoneX = function monotoneX(context) {
  return new MonotoneX(context);
};

function AreaComponent(_ref) {
  var _secondaryAxis$curve;

  var primaryAxis = _ref.primaryAxis,
      secondaryAxis = _ref.secondaryAxis,
      allSeries = _ref.series;

  var _useChartContext = useChartContext(),
      getSeriesStatusStyle = _useChartContext.getSeriesStatusStyle,
      getDatumStatusStyle = _useChartContext.getDatumStatusStyle,
      useFocusedDatumAtom = _useChartContext.useFocusedDatumAtom,
      gridDimensions = _useChartContext.gridDimensions;

  var curve = (_secondaryAxis$curve = secondaryAxis.curve) != null ? _secondaryAxis$curve : monotoneX;

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      focusedDatum = _useFocusedDatumAtom[0];

  var xAxis = primaryAxis.isVertical ? secondaryAxis : primaryAxis;
  var yAxis = !primaryAxis.isVertical ? secondaryAxis : primaryAxis;

  var getX = function getX(datum) {
    var _datum$stackData;

    return xAxis.scale(xAxis.stacked ? (_datum$stackData = datum.stackData) == null ? void 0 : _datum$stackData[1] : xAxis.getValue(datum.originalDatum));
  };

  var getY = function getY(datum, isEnd) {
    var _datum$stackData2;

    return yAxis.scale(yAxis.stacked ? (_datum$stackData2 = datum.stackData) == null ? void 0 : _datum$stackData2[isEnd] : yAxis.getValue(datum.originalDatum));
  };

  return React__default.createElement("g", {
    style: {
      transform: translate(gridDimensions.gridX, gridDimensions.gridY)
    }
  }, allSeries.map(function (series, i) {
    var _area$curve, _line$curve;

    var style = getSeriesStatusStyle(series, focusedDatum);

    var lineStyle = _extends({
      strokeWidth: 2
    }, style, style.line, {
      fill: 'none'
    });

    var areaStyle = _extends({
      strokeWidth: 2,
      opacity: 0.5
    }, style, style.area);

    var areaPath = (_area$curve = area(function (datum) {
      var _getX;

      return (_getX = getX(datum)) != null ? _getX : NaN;
    }, function (datum) {
      var _getY;

      return (_getY = getY(datum, 0)) != null ? _getY : NaN;
    }, function (datum) {
      var _getY2;

      return (_getY2 = getY(datum, 1)) != null ? _getY2 : NaN;
    }).curve(curve)(series.datums)) != null ? _area$curve : undefined;
    var linePath = (_line$curve = line(function (datum) {
      var _getX2;

      return (_getX2 = getX(datum)) != null ? _getX2 : NaN;
    }, function (datum) {
      var _getY3;

      return (_getY3 = getY(datum, 1)) != null ? _getY3 : NaN;
    }).curve(curve)(series.datums)) != null ? _line$curve : undefined;
    return React__default.createElement("g", {
      key: "lines-" + i
    }, React__default.createElement("path", {
      d: areaPath,
      style: areaStyle
    }), React__default.createElement("path", {
      d: linePath,
      style: lineStyle
    }), series.datums.map(function (datum, i) {
      var _getY4, _secondaryAxis$showDa;

      var dataStyle = getDatumStatusStyle(datum, focusedDatum);
      return React__default.createElement("circle", {
        key: i,
        ref: function ref(el) {
          datum.element = el;
        },
        r: 2,
        cx: getX(datum),
        cy: (_getY4 = getY(datum, 1)) != null ? _getY4 : NaN,
        stroke: "rgba(33,33,33,0.5)",
        style: _extends({
          // @ts-ignore
          r: 2
        }, style, style.circle, dataStyle, dataStyle.circle, !((_secondaryAxis$showDa = secondaryAxis.showDatumElements) != null ? _secondaryAxis$showDa : true) ? {
          opacity: 0
        } : {})
      });
    }));
  }));
}

function BarComponent(_ref) {
  var primaryAxis = _ref.primaryAxis,
      secondaryAxis = _ref.secondaryAxis,
      allSeries = _ref.series;

  var _useChartContext = useChartContext(),
      getSeriesStatusStyle = _useChartContext.getSeriesStatusStyle,
      getDatumStatusStyle = _useChartContext.getDatumStatusStyle,
      useFocusedDatumAtom = _useChartContext.useFocusedDatumAtom,
      gridDimensions = _useChartContext.gridDimensions;

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      focusedDatum = _useFocusedDatumAtom[0];

  return React__default.createElement("g", {
    style: {
      transform: translate(gridDimensions.gridX, gridDimensions.gridY)
    }
  }, allSeries.map(function (series, i) {
    var style = getSeriesStatusStyle(series, focusedDatum);
    return React__default.createElement("g", {
      key: "lines-" + i
    }, series.datums.map(function (datum, i) {
      var _getX, _getY, _getWidth, _getHeight;

      var dataStyle = getDatumStatusStyle(datum, focusedDatum);
      return React__default.createElement("rect", {
        ref: function ref(el) {
          datum.element = el;
        },
        key: i,
        x: (_getX = getX(datum, primaryAxis, secondaryAxis)) != null ? _getX : NaN,
        y: (_getY = getY(datum, primaryAxis, secondaryAxis)) != null ? _getY : NaN,
        width: (_getWidth = getWidth(datum, primaryAxis, secondaryAxis)) != null ? _getWidth : NaN,
        height: (_getHeight = getHeight(datum, primaryAxis, secondaryAxis)) != null ? _getHeight : NaN,
        style: _extends({
          strokeWidth: 0
        }, style, style.rectangle, dataStyle, dataStyle.rectangle)
      });
    }));
  }));
}

var pathDefaultStyle = {
  strokeWidth: 2
};
function Line(_ref) {
  var _secondaryAxis$curve;

  var primaryAxis = _ref.primaryAxis,
      secondaryAxis = _ref.secondaryAxis,
      allSeries = _ref.series;

  var _useChartContext = useChartContext(),
      getSeriesStatusStyle = _useChartContext.getSeriesStatusStyle,
      getDatumStatusStyle = _useChartContext.getDatumStatusStyle,
      useFocusedDatumAtom = _useChartContext.useFocusedDatumAtom,
      gridDimensions = _useChartContext.gridDimensions;

  var curve = (_secondaryAxis$curve = secondaryAxis.curve) != null ? _secondaryAxis$curve : monotoneX;

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      focusedDatum = _useFocusedDatumAtom[0];

  var xAxis = primaryAxis.isVertical ? secondaryAxis : primaryAxis;
  var yAxis = !primaryAxis.isVertical ? secondaryAxis : primaryAxis;

  var getX = function getX(datum) {
    var _datum$stackData;

    return xAxis.scale(xAxis.stacked ? (_datum$stackData = datum.stackData) == null ? void 0 : _datum$stackData[1] : xAxis.getValue(datum.originalDatum));
  };

  var getY = function getY(datum) {
    var _datum$stackData2;

    return yAxis.scale(yAxis.stacked ? (_datum$stackData2 = datum.stackData) == null ? void 0 : _datum$stackData2[1] : yAxis.getValue(datum.originalDatum));
  };

  return React__default.createElement("g", {
    style: {
      transform: translate(gridDimensions.gridX, gridDimensions.gridY)
    }
  }, allSeries.map(function (series, i) {
    var _line$curve;

    var style = getSeriesStatusStyle(series, focusedDatum);

    var lineStyle = _extends({}, pathDefaultStyle, style, style.line, {
      fill: 'none'
    });

    var linePath = (_line$curve = line(function (datum) {
      var _getX;

      return (_getX = getX(datum)) != null ? _getX : NaN;
    }, function (datum) {
      var _getY;

      return (_getY = getY(datum)) != null ? _getY : NaN;
    }).curve(curve)(series.datums)) != null ? _line$curve : undefined;
    return React__default.createElement("g", {
      key: "lines-" + i
    }, series.datums.map(function (datum, i) {
      var _secondaryAxis$showDa;

      var dataStyle = getDatumStatusStyle(datum, focusedDatum);
      return React__default.createElement("circle", {
        key: i,
        ref: function ref(el) {
          datum.element = el;
        },
        r: 2,
        cx: getX(datum),
        cy: getY(datum),
        stroke: "rgba(33,33,33,0.5)",
        fill: "transparent",
        style: _extends({
          // @ts-ignore
          r: 2
        }, style, style.circle, dataStyle, dataStyle.circle, !((_secondaryAxis$showDa = secondaryAxis.showDatumElements) != null ? _secondaryAxis$showDa : true) ? {
          opacity: 0
        } : {})
      });
    }), React__default.createElement("path", {
      d: linePath,
      style: lineStyle
    }));
  }));
}

function defaultAxisOptions(options) {
  var _options$elementType, _options$minTickPaddi, _options$tickLabelRot, _options$innerBandPad, _options$outerBandPad, _options$show, _options$stacked;

  return _extends({}, options, {
    elementType: (_options$elementType = options.elementType) != null ? _options$elementType : 'line',
    // tickCount: options.tickCount ?? 10,
    // minTickCount: options.minTickCount ?? 1,
    // maxTickCount: options.maxTickCount ?? 99999999,
    // tickSizeInner: options.tickSizeInner ?? 6,
    // tickSizeOuter: options.tickSizeOuter ?? 6,
    minTickPaddingForRotation: (_options$minTickPaddi = options.minTickPaddingForRotation) != null ? _options$minTickPaddi : 10,
    tickLabelRotationDeg: (_options$tickLabelRot = options.tickLabelRotationDeg) != null ? _options$tickLabelRot : 60,
    innerBandPadding: (_options$innerBandPad = options.innerBandPadding) != null ? _options$innerBandPad : 0.6,
    outerBandPadding: (_options$outerBandPad = options.outerBandPadding) != null ? _options$outerBandPad : 0.2,
    // showTicks: options.showTicks ?? true,
    // filterTicks: options.filterTicks ?? (d => d),
    show: (_options$show = options.show) != null ? _options$show : true,
    stacked: (_options$stacked = options.stacked) != null ? _options$stacked : false
  });
}

function buildAxisLinear(userOptions, series, gridDimensions, width, height) {
  var options = defaultAxisOptions(userOptions);

  if (!options.position) {
    throw new Error("Chart axes must have a valid 'position' property");
  }

  var isVertical = ['left', 'right'].indexOf(options.position) > -1; // Now we need to figure out the range

  var range = isVertical ? [gridDimensions.gridHeight, 0] : [0, gridDimensions.gridWidth];
  var outerRange = isVertical ? [height, 0] : [0, width]; // Give the scale a home

  return options.scaleType === 'time' || options.scaleType === 'localTime' ? buildTimeAxis(options, series, isVertical, range, outerRange) : options.scaleType === 'linear' || options.scaleType === 'log' ? buildLinearAxis(options, series, isVertical, range, outerRange) : options.scaleType === 'band' ? buildBandAxis(options, series, isVertical, range, outerRange) : function () {
    throw new Error('Invalid scale type');
  }(); // @ts-ignore
  // const scaleFormat = scale.tickFormat ? scale.tickFormat() : d => d
  // const userFormat = options?.format
  // const format = userFormat
  //   ? (value: unknown, index: number) =>
  //       userFormat(value, index, scaleFormat(value))
  //   : scaleFormat
  // const resolvedTickCount = options.tickCount
  // const ticks = options.filterTicks(
  //   options.tickValues ||
  //     // @ts-ignore
  //     (scale.ticks ? scale.ticks(resolvedTickCount) : scale.domain())
  // )
  // const scaleMax =
  //   options.position === 'bottom'
  //     ? -gridDimensions.gridHeight
  //     : options.position === 'left'
  //     ? gridDimensions.gridWidth
  //     : options.position === 'top'
  //     ? gridDimensions.gridHeight
  //     : -gridDimensions.gridWidth
  // // const directionMultiplier =
  // //   options.position === 'top' || options.position === 'left' ? -1 : 1
  // const transform = !isVertical ? translateX : translateY
  // const tickSpacing = Math.max(options.tickSizeInner, 0) + options.tickPadding
  // Pass down the axis config (including the scale itself) for posterity
}

function buildTimeAxis(options, series, isVertical, range, outerRange) {
  var scaleFn = options.scaleType === 'localTime' ? scaleTime : scaleUtc; // Now set the range

  var scale = scaleFn(range);
  var allDatums = series.map(function (d) {
    return d.datums;
  }).flat();

  var _extent = extent(allDatums, function (datum) {
    return options.getValue(datum.originalDatum);
  }),
      minValue = _extent[0],
      maxValue = _extent[1];

  if (minValue === undefined || maxValue === undefined) {
    console.info({
      options: options,
      series: series,
      range: range,
      values: allDatums.map(function (d) {
        return options.getValue(d.originalDatum);
      })
    });
    throw new Error('Invalid scale min/max');
  } // Set the domain


  scale.domain([minValue, maxValue]);

  if (typeof options.hardMin === 'number') {
    scale.domain([options.hardMin, Number(scale.domain()[1])]);
  }

  if (typeof options.hardMax === 'number') {
    scale.domain([Number(scale.domain()[0]), options.hardMax]);
  }

  if (options.invert) {
    scale.domain(Array.from(scale.domain()).reverse());
  }

  scale.nice();
  var outerScale = scale.copy().range(outerRange); // Supplmentary band scale

  var bandScale = buildImpliedBandScale(options, scale, series, range);
  var defaultFormat = scale.tickFormat();
  var formatters = {};

  var scaleFormat = function scaleFormat(value) {
    var _options$formatters$s, _options$formatters;

    return (_options$formatters$s = (_options$formatters = options.formatters) == null ? void 0 : _options$formatters.scale == null ? void 0 : _options$formatters.scale(value, _extends({}, formatters, {
      scale: undefined
    }))) != null ? _options$formatters$s : defaultFormat(value);
  };

  var tooltipFormat = function tooltipFormat(value) {
    var _options$formatters$t, _options$formatters2;

    return (_options$formatters$t = (_options$formatters2 = options.formatters) == null ? void 0 : _options$formatters2.tooltip == null ? void 0 : _options$formatters2.tooltip(value, _extends({}, formatters, {
      tooltip: undefined
    }))) != null ? _options$formatters$t : scaleFormat(value);
  };

  var cursorFormat = function cursorFormat(value) {
    var _options$formatters$c, _options$formatters3;

    return (_options$formatters$c = (_options$formatters3 = options.formatters) == null ? void 0 : _options$formatters3.cursor == null ? void 0 : _options$formatters3.cursor(value, _extends({}, formatters, {
      cursor: undefined
    }))) != null ? _options$formatters$c : tooltipFormat(value);
  };

  Object.assign(formatters, {
    "default": defaultFormat,
    scale: scaleFormat,
    tooltip: tooltipFormat,
    cursor: cursorFormat
  });
  return _extends({}, options, {
    axisFamily: 'time',
    isVertical: isVertical,
    scale: scale,
    range: range,
    outerScale: outerScale,
    bandScale: bandScale,
    formatters: formatters
  });
}

function buildLinearAxis(options, series, isVertical, range, outerRange) {
  var scale = options.scaleType === 'log' ? scaleLog() : scaleLinear();
  var allDatums = series.map(function (d) {
    return d.datums;
  }).flat(2);

  var _ref = options.stacked ? extent(series.map(function (s) {
    return s.datums.map(function (datum) {
      var _datum$stackData;

      return (_datum$stackData = datum.stackData) != null ? _datum$stackData : [];
    });
  }).flat(2)) : extent(allDatums, function (datum) {
    return options.getValue(datum.originalDatum);
  }),
      minValue = _ref[0],
      maxValue = _ref[1];

  if (minValue === undefined || maxValue === undefined) {
    console.info({
      options: options,
      series: series,
      range: range,
      values: allDatums.map(function (d) {
        return options.getValue(d.originalDatum);
      })
    });
    throw new Error('Invalid scale min/max');
  } // Set the domain


  scale.domain([minValue, maxValue]);

  if (typeof options.hardMin === 'number') {
    scale.domain([options.hardMin, Number(scale.domain()[1])]);
  }

  if (typeof options.hardMax === 'number') {
    scale.domain([Number(scale.domain()[0]), options.hardMax]);
  }

  if (options.invert) {
    scale.domain(Array.from(scale.domain()).reverse());
  }

  scale.range(range);
  scale.nice();
  var outerScale = scale.copy().range(outerRange);
  var bandScale = buildImpliedBandScale(options, scale, series, range);
  var defaultFormat = scale.tickFormat();
  var formatters = {};

  var scaleFormat = function scaleFormat(value) {
    var _options$formatters$s2, _options$formatters4;

    return (_options$formatters$s2 = (_options$formatters4 = options.formatters) == null ? void 0 : _options$formatters4.scale == null ? void 0 : _options$formatters4.scale(value, _extends({}, formatters, {
      scale: undefined
    }))) != null ? _options$formatters$s2 : defaultFormat(value);
  };

  var tooltipFormat = function tooltipFormat(value) {
    var _options$formatters$t2, _options$formatters5;

    return (_options$formatters$t2 = (_options$formatters5 = options.formatters) == null ? void 0 : _options$formatters5.tooltip == null ? void 0 : _options$formatters5.tooltip(value, _extends({}, formatters, {
      tooltip: undefined
    }))) != null ? _options$formatters$t2 : scaleFormat(value);
  };

  var cursorFormat = function cursorFormat(value) {
    var _options$formatters$c2, _options$formatters6;

    return (_options$formatters$c2 = (_options$formatters6 = options.formatters) == null ? void 0 : _options$formatters6.cursor == null ? void 0 : _options$formatters6.cursor(value, _extends({}, formatters, {
      cursor: undefined
    }))) != null ? _options$formatters$c2 : tooltipFormat(value);
  };

  Object.assign(formatters, {
    "default": defaultFormat,
    scale: scaleFormat,
    tooltip: tooltipFormat,
    cursor: cursorFormat
  });
  return _extends({}, options, {
    axisFamily: 'linear',
    isVertical: isVertical,
    scale: scale,
    range: range,
    outerScale: outerScale,
    bandScale: bandScale,
    formatters: formatters
  });
}

function buildBandAxis(options, series, isVertical, range, outerRange) {
  var _options$outerBandPad2, _options$innerBandPad2;

  var domain = Array.from(new Set(series.map(function (d) {
    return d.datums;
  }).flat().map(function (datum) {
    return options.getValue(datum.originalDatum);
  })));
  var scale = scaleBand(domain, range).round(false).paddingOuter((_options$outerBandPad2 = options.outerBandPadding) != null ? _options$outerBandPad2 : 0).paddingInner((_options$innerBandPad2 = options.innerBandPadding) != null ? _options$innerBandPad2 : 0); // Invert if necessary

  if (options.invert) {
    scale.domain(Array.from(scale.domain()).reverse());
  }

  var outerScale = scale.copy().range(outerRange);

  var defaultFormat = function defaultFormat(d) {
    return d;
  };

  var formatters = {};

  var scaleFormat = function scaleFormat(value) {
    var _options$formatters$s3, _options$formatters7;

    return (_options$formatters$s3 = (_options$formatters7 = options.formatters) == null ? void 0 : _options$formatters7.scale == null ? void 0 : _options$formatters7.scale(value, _extends({}, formatters, {
      scale: undefined
    }))) != null ? _options$formatters$s3 : defaultFormat(value);
  };

  var tooltipFormat = function tooltipFormat(value) {
    var _options$formatters$t3, _options$formatters8;

    return (_options$formatters$t3 = (_options$formatters8 = options.formatters) == null ? void 0 : _options$formatters8.tooltip == null ? void 0 : _options$formatters8.tooltip(value, _extends({}, formatters, {
      tooltip: undefined
    }))) != null ? _options$formatters$t3 : scaleFormat(value);
  };

  var cursorFormat = function cursorFormat(value) {
    var _options$formatters$c3, _options$formatters9;

    return (_options$formatters$c3 = (_options$formatters9 = options.formatters) == null ? void 0 : _options$formatters9.cursor == null ? void 0 : _options$formatters9.cursor(value, _extends({}, formatters, {
      cursor: undefined
    }))) != null ? _options$formatters$c3 : tooltipFormat(value);
  };

  Object.assign(formatters, {
    "default": defaultFormat,
    scale: scaleFormat,
    tooltip: tooltipFormat,
    cursor: cursorFormat
  });
  return _extends({}, options, {
    axisFamily: 'band',
    isVertical: isVertical,
    scale: scale,
    range: range,
    outerScale: outerScale,
    formatters: formatters
  });
} //


function buildImpliedBandScale(options, scale, series, range$1) {
  var _options$outerBandPad3, _options$innerBandPad3;

  // Find the two closest points along axis
  var impliedBandWidth = Math.max.apply(Math, range$1);
  series.forEach(function (serie) {
    serie.datums.forEach(function (d1) {
      var _options$getValue;

      var one = scale((_options$getValue = options.getValue(d1.originalDatum)) != null ? _options$getValue : NaN);
      serie.datums.forEach(function (d2) {
        var _options$getValue2;

        var two = scale((_options$getValue2 = options.getValue(d2.originalDatum)) != null ? _options$getValue2 : NaN);

        if (one === two) {
          return;
        }

        var r = [one, two].sort();
        var diff = Math.abs(r[1] - r[0]);

        if (diff < impliedBandWidth) {
          impliedBandWidth = diff;
        }
      });
    });
  });
  var bandRange = Math.max.apply(Math, range$1);
  var bandDomain = range(bandRange / impliedBandWidth);
  var bandScale = scaleBand(bandDomain, range$1).round(false).paddingOuter((_options$outerBandPad3 = options.outerBandPadding) != null ? _options$outerBandPad3 : 0).paddingInner((_options$innerBandPad3 = options.innerBandPadding) != null ? _options$innerBandPad3 : 0);
  return bandScale;
}

var getElBox = function getElBox(el) {
  var rect = el.getBoundingClientRect();
  return {
    top: Math.round(rect.top),
    right: Math.round(rect.right),
    bottom: Math.round(rect.bottom),
    left: Math.round(rect.left),
    width: Math.round(rect.width),
    height: Math.round(rect.height),
    x: Math.round(rect.x),
    y: Math.round(rect.y)
  };
};

function useMeasure(_ref) {
  var axis = _ref.axis,
      elRef = _ref.elRef,
      gridDimensions = _ref.gridDimensions,
      setShowRotated = _ref.setShowRotated;

  var _useChartContext = useChartContext(),
      useAxisDimensionsAtom = _useChartContext.useAxisDimensionsAtom;

  var _useAxisDimensionsAto = useAxisDimensionsAtom(),
      axisDimensions = _useAxisDimensionsAto[0],
      setAxisDimensions = _useAxisDimensionsAto[1];

  var axisDimension = React__default.useMemo(function () {
    var _axisDimensions$axis$;

    return (_axisDimensions$axis$ = axisDimensions[axis.position]) == null ? void 0 : _axisDimensions$axis$[axis.id];
  }, [axisDimensions, axis.position, axis.id]); // const isLooping = useIsLooping()

  var measureRotation = React__default.useCallback(function () {
    var _widestLabel2;

    if (!elRef.current) {
      return;
    }

    var gridSize = !axis.isVertical ? gridDimensions.gridWidth : gridDimensions.gridHeight;
    var staticLabelDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.outer .tickLabel')).map(function (el) {
      return getElBox(el);
    }); // Determine the largest labels on the axis

    var widestLabel;
    staticLabelDims.forEach(function (label) {
      var _widestLabel;

      var resolvedLabel = (_widestLabel = widestLabel) != null ? _widestLabel : {
        width: 0
      };

      if (label.width > 0 && label.width > resolvedLabel.width) {
        widestLabel = label;
      }
    });
    var smallestTickGap = gridSize;

    if (staticLabelDims.length > 1) {
      staticLabelDims.forEach(function (current, i) {
        var prev = staticLabelDims[i - 1];

        if (prev) {
          smallestTickGap = Math.min(smallestTickGap, axis.isVertical ? current.top - prev.top : current.left - prev.left);
        }
      });
    }

    var shouldRotate = (((_widestLabel2 = widestLabel) == null ? void 0 : _widestLabel2.width) || 0) + axis.minTickPaddingForRotation > smallestTickGap; // if (!isLooping) {
    // Rotate ticks for non-time horizontal axes

    if (!axis.isVertical) {
      setShowRotated(shouldRotate);
    } // }

  }, [elRef, axis.isVertical, axis.minTickPaddingForRotation, gridDimensions.gridWidth, gridDimensions.gridHeight, setShowRotated]);
  var measureDimensions = React__default.useCallback(function () {
    if (!elRef.current) {
      if (axisDimension) {
        // If the entire axis is hidden, then we need to remove the axis dimensions
        setAxisDimensions(function (old) {
          var _old$axis$position, _extends2;

          var newAxes = _extends({}, (_old$axis$position = old[axis.position]) != null ? _old$axis$position : {});

          delete newAxes[axis.id];
          return _extends({}, old, (_extends2 = {}, _extends2[axis.position] = newAxes, _extends2));
        });
      }

      return;
    }

    var newDimensions = {
      width: 0,
      height: 0,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    var domainEl = elRef.current.querySelector(".Axis-Group.inner .domain");

    if (!domainEl) {
      return;
    }

    var domainDims = getElBox(domainEl);
    var measureDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.inner .tickLabel')).map(function (el) {
      return getElBox(el);
    }); // Determine the largest labels on the axis

    var widestRealLabel = measureDims[0];
    var tallestRealLabel = measureDims[0];
    measureDims.forEach(function (d) {
      if (d.width > 0 && d.width > widestRealLabel.width) {
        widestRealLabel = d;
      }

      if (d.height > 0 && d.height > tallestRealLabel.height) {
        tallestRealLabel = d;
      }
    }); // Axis overflow measurements

    if (!axis.isVertical) {
      var _tallestRealLabel$hei, _tallestRealLabel;

      if (measureDims.length) {
        var leftMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.left < d.left ? labelDim : d;
        });
        var rightMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.right > d.right ? labelDim : d;
        });
        newDimensions.left = Math.round(Math.max(0, domainDims.left - (leftMostLabelDim == null ? void 0 : leftMostLabelDim.left)));
        newDimensions.right = Math.round(Math.max(0, (rightMostLabelDim == null ? void 0 : rightMostLabelDim.right) - domainDims.right));
      }

      newDimensions.height = Math.round( // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +
      8 + axis.minTickPaddingForRotation + ((_tallestRealLabel$hei = (_tallestRealLabel = tallestRealLabel) == null ? void 0 : _tallestRealLabel.height) != null ? _tallestRealLabel$hei : 0));
    } else {
      var _widestRealLabel$widt, _widestRealLabel;

      if (measureDims.length) {
        var topMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.top < d.top ? labelDim : d;
        });
        var bottomMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.bottom > d.bottom ? labelDim : d;
        });
        newDimensions.top = Math.round(Math.max(0, domainDims.top - (topMostLabelDim == null ? void 0 : topMostLabelDim.top)));
        newDimensions.bottom = Math.round(Math.max(0, (bottomMostLabelDim == null ? void 0 : bottomMostLabelDim.bottom) - domainDims.bottom));
      }

      newDimensions.width = Math.round( // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +
      8 + axis.minTickPaddingForRotation + ((_widestRealLabel$widt = (_widestRealLabel = widestRealLabel) == null ? void 0 : _widestRealLabel.width) != null ? _widestRealLabel$widt : 0));
    } // Only update the axisDimensions if something has changed


    if ( // !isLooping &&
    !axisDimensions || !axisDimension || Object.keys(newDimensions).some(function (key) {
      // @ts-ignore
      return newDimensions[key] !== axisDimension[key];
    })) {
      setAxisDimensions(function (old) {
        var _old$axis$position2, _extends3, _extends4;

        return _extends({}, old, (_extends4 = {}, _extends4[axis.position] = _extends({}, (_old$axis$position2 = old[axis.position]) != null ? _old$axis$position2 : {}, (_extends3 = {}, _extends3[axis.id] = newDimensions, _extends3)), _extends4));
      });
    }
  }, [axis.id, axis.isVertical, axis.position, axis.minTickPaddingForRotation, axisDimension, axisDimensions, elRef, setAxisDimensions]); // Measure after if needed

  useIsomorphicLayoutEffect(function () {
    measureRotation();
  }, [measureRotation]);
  useIsomorphicLayoutEffect(function () {
    measureDimensions();
  }, [measureRotation]);
}

function AxisLinearComp(axis) {
  var _React$useState = React__default.useState(false),
      showRotated = _React$useState[0],
      setShowRotated = _React$useState[1];

  var _useChartContext = useChartContext(),
      getOptions = _useChartContext.getOptions,
      gridDimensions = _useChartContext.gridDimensions,
      width = _useChartContext.width,
      height = _useChartContext.height;

  var _getOptions = getOptions(),
      dark = _getOptions.dark,
      showDebugAxes = _getOptions.showDebugAxes;

  var elRef = React__default.useRef(null);
  useMeasure({
    axis: axis,
    elRef: elRef,
    gridDimensions: gridDimensions,
    showRotated: showRotated,
    setShowRotated: setShowRotated
  });

  var renderAxis = function renderAxis(isOuter) {
    var isRotated = !isOuter && showRotated;
    var scale = isOuter ? axis.outerScale : axis.scale;

    var _scale$range = scale.range(),
        rangeStart = _scale$range[0],
        rangeEnd = _scale$range[1];

    var getTicks = function getTicks(scale, num) {
      if (scale.ticks) {
        return scale.ticks(num);
      }

      return scale.domain();
    };

    var resolvedHeight = isOuter ? height : gridDimensions.gridHeight;
    var resolvedWidth = isOuter ? width : gridDimensions.gridWidth;

    var _ref = axis.position === 'left' ? [{
      x: 0,
      y: rangeStart
    }, {
      x: 0,
      y: rangeEnd
    }] : axis.position === 'right' ? [{
      x: resolvedWidth,
      y: rangeStart
    }, {
      x: resolvedWidth,
      y: rangeEnd
    }] : axis.position === 'top' ? [{
      x: rangeStart,
      y: 0
    }, {
      x: rangeEnd,
      y: 0
    }] : [{
      x: rangeStart,
      y: resolvedHeight
    }, {
      x: rangeEnd,
      y: resolvedHeight
    }],
        lineFrom = _ref[0],
        lineTo = _ref[1];

    return React__default.createElement("g", {
      key: "Axis-Group " + (isOuter ? 'outer' : 'inner'),
      className: "Axis-Group " + (isOuter ? 'outer' : 'inner'),
      style: {
        transform: isOuter ? undefined : translate(gridDimensions.gridX, gridDimensions.gridY)
      }
    }, React__default.createElement("g", {
      className: "Axis",
      style: _extends({}, isOuter ? {
        opacity: showDebugAxes ? 0.5 : 0,
        pointerEvents: 'none'
      } : {
        opacity: 1,
        pointerEvents: 'all'
      })
    }, React__default.createElement("line", {
      className: "domain",
      x1: lineFrom.x,
      y1: lineFrom.y,
      x2: lineTo.x,
      y2: lineTo.y,
      stroke: dark ? 'rgba(255,255,255, .2)' : 'rgba(0,0,0, .2)'
    }), getTicks(scale, 10).map(function (tick, i) {
      var _axis$showGrid;

      var px = getTickPx(scale, tick);

      var _ref2 = axis.position === 'left' ? [{
        x: 0,
        y: px
      }, {
        x: -8,
        y: px
      }, {
        x: resolvedWidth,
        y: px
      }] : axis.position === 'right' ? [{
        x: resolvedWidth,
        y: px
      }, {
        x: resolvedWidth + 8,
        y: px
      }, {
        x: 0,
        y: px
      }] : axis.position === 'top' ? [{
        x: px,
        y: 0
      }, {
        x: px,
        y: -8
      }, {
        x: px,
        y: resolvedHeight
      }] : [{
        x: px,
        y: resolvedHeight
      }, {
        x: px,
        y: resolvedHeight + 8
      }, {
        x: px,
        y: 0
      }],
          tickFrom = _ref2[0],
          tickTo = _ref2[1],
          gridTo = _ref2[2];

      var tickLabelX = tickTo.x,
          tickLabelY = tickTo.y;

      if (axis.position === 'top') {
        tickLabelY -= 5;
      } else if (axis.position === 'bottom') {
        tickLabelY += 5;
      } else if (axis.position === 'left') {
        tickLabelX -= 5;
      } else if (axis.position === 'right') {
        tickLabelX += 5;
      }

      return React__default.createElement("g", {
        key: "vx-tick-" + tick + "-" + i,
        className: 'tick'
      }, ((_axis$showGrid = axis.showGrid) != null ? _axis$showGrid : true) && !isOuter ? React__default.createElement("line", {
        x1: tickFrom.x,
        y1: tickFrom.y,
        x2: gridTo.x,
        y2: gridTo.y,
        stroke: dark ? 'rgba(255,255,255, .05)' : 'rgba(0,0,0, .05)'
      }) : null, !isOuter ? React__default.createElement("line", {
        x1: tickFrom.x,
        y1: tickFrom.y,
        x2: tickTo.x,
        y2: tickTo.y,
        stroke: dark ? 'rgba(255,255,255, .2)' : 'rgba(0,0,0, .2)'
      }) : null, React__default.createElement("text", {
        className: "tickLabel",
        style: {
          fontSize: 10,
          fill: dark ? 'rgba(255,255,255, .7)' : 'rgba(0,0,0, .7)',
          dominantBaseline: isRotated ? 'central' : axis.position === 'bottom' ? 'hanging' : axis.position === 'top' ? 'alphabetic' : 'central',
          textAnchor: isRotated ? 'end' : axis.position === 'right' ? 'start' : axis.position === 'left' ? 'end' : 'middle'
        },
        transform: "translate(" + tickLabelX + ", " + tickLabelY + ") rotate(" + (isRotated ? axis.position === 'top' ? 60 : -60 : 0) + ")"
      }, axis.formatters.scale(tick)));
    })));
  };

  return axis.show ? React__default.createElement("g", {
    ref: elRef
  }, renderAxis(false), renderAxis(true)) : null;
}

function useLatestWhen(obj, when) {
  if (when === void 0) {
    when = true;
  }

  var ref = React__default.useRef(when ? obj : null);

  if (when) {
    ref.current = obj;
  }

  return ref.current;
}

function usePortalElement() {
  var _React$useState = useState(),
      portalEl = _React$useState[0],
      setPortalEl = _React$useState[1];

  useIsomorphicLayoutEffect(function () {
    if (!portalEl) {
      var element = document.getElementById('react-charts-portal');

      if (!element) {
        element = document.createElement('div');
        element.setAttribute('id', 'react-charts-portal');
        Object.assign(element.style, {
          pointerEvents: 'none',
          position: 'fixed',
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          'z-index': 99999999999
        });
        document.body.append(element);
      }

      setPortalEl(element);
    }
  });
  return portalEl;
}

var getLineBackgroundColor = function getLineBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)';
};

var getBackgroundColor = function getBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';
};

function defaultCursor(options) {
  var _options$show, _options$showLine, _options$showLabel;

  return _extends({}, options, {
    show: (_options$show = options.show) != null ? _options$show : true,
    showLine: (_options$showLine = options.showLine) != null ? _options$showLine : true,
    showLabel: (_options$showLabel = options.showLabel) != null ? _options$showLabel : true
  });
}

function Cursors() {
  var _getOptions$primaryCu, _getOptions$secondary;

  var _useChartContext = useChartContext(),
      getOptions = _useChartContext.getOptions;

  var primaryOptions = (_getOptions$primaryCu = getOptions().primaryCursor) != null ? _getOptions$primaryCu : true;
  var secondaryOptions = (_getOptions$secondary = getOptions().secondaryCursor) != null ? _getOptions$secondary : true;
  var resolvedPrimaryOptions = React__default.useMemo(function () {
    return defaultCursor(!primaryOptions ? {
      show: false
    } : typeof primaryOptions === 'boolean' ? {} : primaryOptions);
  }, [primaryOptions]);
  var resolvedSecondaryOptions = React__default.useMemo(function () {
    return defaultCursor(!secondaryOptions ? {
      show: false
    } : typeof secondaryOptions === 'boolean' ? {} : secondaryOptions);
  }, [secondaryOptions]);
  return React__default.createElement(React__default.Fragment, null, React__default.createElement(Cursor, {
    primary: true,
    options: resolvedPrimaryOptions
  }), React__default.createElement(Cursor, {
    options: resolvedSecondaryOptions
  }));
}

function Cursor(props) {
  var _useChartContext2 = useChartContext(),
      getOptions = _useChartContext2.getOptions,
      svgRect = _useChartContext2.svgRect,
      gridDimensions = _useChartContext2.gridDimensions,
      useFocusedDatumAtom = _useChartContext2.useFocusedDatumAtom,
      primaryAxis = _useChartContext2.primaryAxis,
      secondaryAxes = _useChartContext2.secondaryAxes;

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      focusedDatum = _useFocusedDatumAtom[0];

  var latestFocusedDatum = useLatestWhen(focusedDatum, !!focusedDatum);
  var secondaryAxis = secondaryAxes.find(function (d) {
    return d.id === props.options.axisId || (latestFocusedDatum == null ? void 0 : latestFocusedDatum.secondaryAxisId);
  });
  var axis = props.primary ? primaryAxis : secondaryAxis;
  var siblingAxis = props.primary ? secondaryAxis : primaryAxis;

  var resolveValue = function resolveValue(d) {
    var _props$options$value, _d$stackData;

    return (_props$options$value = props.options.value) != null ? _props$options$value : d ? axis.stacked ? (_d$stackData = d.stackData) == null ? void 0 : _d$stackData[1] : axis.getValue(d == null ? void 0 : d.originalDatum) : undefined;
  };

  var value = resolveValue(focusedDatum);
  var latestValue = resolveValue(latestFocusedDatum); // Get the sibling range

  var siblingRange = siblingAxis.scale.range();
  var x;
  var y;
  var x1;
  var x2;
  var y1;
  var y2;
  var alignPctX;
  var alignPctY;
  var bandWidth = axis.axisFamily === 'band' ? axis.scale.bandwidth() : 1;
  var px = axis.scale(latestValue);
  var show = typeof value !== 'undefined' && !Number.isNaN(value); // Vertical alignment

  if (axis.isVertical) {
    var _y, _y2;

    y = px;
    y1 = ((_y = y) != null ? _y : 0) - 1;
    y2 = ((_y2 = y) != null ? _y2 : 0) + bandWidth;

    if (axis.position === 'left') {
      x1 = siblingRange[0];
      x2 = siblingRange[1];
    } else {
      x1 = siblingRange[1];
      x2 = siblingRange[0];
    }
  } else {
    var _x, _x2;

    x = px;
    x1 = ((_x = x) != null ? _x : 0) - 1;
    x2 = ((_x2 = x) != null ? _x2 : 0) + bandWidth;

    if (axis.position === 'top') {
      y1 = siblingRange[0];
      y2 = siblingRange[1];
    } else {
      y1 = siblingRange[1];
      y2 = siblingRange[0];
    }
  }

  var lineStartX = Math.min(x1, x2);
  var lineStartY = Math.min(y1, y2);
  var lineEndX = Math.max(x1, x2);
  var lineEndY = Math.max(y1, y2);
  var lineHeight = Math.max(lineEndY - lineStartY, 0);
  var lineWidth = Math.max(lineEndX - lineStartX, 0);
  var bubbleX;
  var bubbleY; // Bubble placement

  if (axis.isVertical) {
    if (axis.position === 'left') {
      bubbleX = lineStartX;
    } else {
      bubbleX = lineEndX;
    }

    bubbleY = lineStartY + lineHeight / 2;
  } else {
    if (axis.position === 'top') {
      bubbleY = lineStartY;
    } else {
      bubbleY = lineEndY;
    }

    bubbleX = lineStartX + lineWidth / 2;
  } // Bubble anchoring


  if (axis.isVertical) {
    alignPctY = -50;

    if (axis.position === 'left') {
      alignPctX = -100;
    } else {
      alignPctX = 0;
    }
  } else {
    alignPctX = -50;

    if (axis.position === 'top') {
      alignPctY = -100;
    } else {
      alignPctY = 0;
    }
  }

  var formattedValue = axis.formatters.cursor(latestValue); // const isScrolling = useIsScrolling(200)

  var lineSpring = useSpring({
    transform: translate(lineStartX, lineStartY),
    width: lineWidth + "px",
    height: lineHeight + "px",
    config: config.stiff // immediate: isScrolling,

  });
  var bubbleSpring = useSpring({
    transform: translate(bubbleX, bubbleY),
    config: config.stiff // immediate: isScrolling,

  });
  var portalEl = usePortalElement();
  return portalEl ? ReactDOM.createPortal(React__default.createElement("div", {
    style: {
      pointerEvents: 'none',
      position: 'absolute',
      top: 0,
      left: 0,
      transform: translate(svgRect.left + gridDimensions.gridX, svgRect.top + gridDimensions.gridY),
      opacity: show ? 1 : 0,
      transition: 'all .3s ease'
    },
    className: "Cursor"
  }, props.options.showLine ? React__default.createElement(animated.div, {
    style: _extends({}, lineSpring, {
      position: 'absolute',
      top: 0,
      left: 0,
      background: getLineBackgroundColor(getOptions().dark)
    })
  }) : null, props.options.showLabel ? React__default.createElement(animated.div, {
    style: _extends({}, bubbleSpring, {
      position: 'absolute',
      top: 0,
      left: 0
    })
  }, React__default.createElement("div", {
    style: {
      padding: '5px',
      fontSize: '10px',
      background: getBackgroundColor(getOptions().dark),
      color: getBackgroundColor(!getOptions().dark),
      borderRadius: '3px',
      position: 'relative',
      transform: "translate3d(" + alignPctX + "%, " + alignPctY + "%, 0)",
      whiteSpace: 'nowrap'
    }
  }, formattedValue)) : null), portalEl) : null;
}

// different sides of a bounding box within another

var sideSchemas = {
  left: {
    side: 'left',
    startKey: 'left',
    lengthKey: 'width',
    crossStartKey: 'top',
    crossLengthKey: 'height',
    fromEnd: false
  },
  right: {
    side: 'right',
    startKey: 'left',
    lengthKey: 'width',
    crossStartKey: 'top',
    crossLengthKey: 'height',
    fromEnd: true
  },
  top: {
    side: 'top',
    startKey: 'top',
    lengthKey: 'height',
    crossStartKey: 'left',
    crossLengthKey: 'width',
    fromEnd: false
  },
  bottom: {
    side: 'bottom',
    startKey: 'top',
    lengthKey: 'height',
    crossStartKey: 'left',
    crossLengthKey: 'width',
    fromEnd: true
  }
}; // This is the final Tootlip component. It's a render prop
// that lets you attach handlers to elements, and render a tooltip
// anchored to them in relation to the parent portal container (either the only
// one defined or the one referenced by Id).

function useAnchor(options) {
  var portalDims = useRect(options.portalEl, {
    enabled: options.show
  });
  var anchorDims = useRect(options.anchorEl, {
    enabled: options.show
  });
  var tooltipDims = useRect(options.tooltipEl, {
    enabled: options.show
  });
  var sides = React__default.useMemo(function () {
    var preSides = Array.isArray(options.side) ? options.side : [options.side];
    return preSides.map(function (alignStr) {
      var _alignStr$split = alignStr.split(' '),
          side = _alignStr$split[0],
          _alignStr$split$ = _alignStr$split[1],
          align = _alignStr$split$ === void 0 ? 'center' : _alignStr$split$;

      var incompatibleSide = !['top', 'right', 'bottom', 'left'].find(function (d) {
        return side === d;
      });

      if (incompatibleSide) {
        throw new Error("react-sticker: \"" + side + "\" is not a valid side! Must be one of ['top', 'right', 'bottom', 'left'].");
      }

      var incompatibleAlign = !['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].find(function (d) {
        return align === d;
      });

      if (incompatibleAlign) {
        throw new Error("react-sticker: \"" + align + "\" is not a valid side-alignment! Must be one of ['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].");
      }

      return [side, align];
    }); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [JSON.stringify(options.side)]); // IF we have all of the dimensions needed to calculate
  // fits, then calculate the fit

  var ready = portalDims && tooltipDims && anchorDims;
  var fit = React__default.useMemo(function () {
    return ready ? fitOnBestSide({
      portalDims: portalDims,
      tooltipDims: tooltipDims,
      anchorDims: anchorDims,
      sides: sides,
      useLargest: options.useLargest
    }) : null;
  }, [anchorDims, options.useLargest, portalDims, ready, sides, tooltipDims]);
  return {
    fit: fit,
    style: _extends({
      position: 'absolute',
      visibility: ready ? 'visible' : 'hidden'
    }, fit == null ? void 0 : fit.style)
  };
} // This function selects the best side for the tooltip by using
// the ranked fits.

function fitOnBestSide(_ref) {
  var portalDims = _ref.portalDims,
      tooltipDims = _ref.tooltipDims,
      anchorDims = _ref.anchorDims,
      sides = _ref.sides,
      useLargest = _ref.useLargest;
  var fits = sides.map(function (_ref2) {
    var side = _ref2[0],
        align = _ref2[1];
    return measureFit(_extends({}, sideSchemas[side], {
      align: align,
      portalDims: portalDims,
      tooltipDims: tooltipDims,
      anchorDims: anchorDims
    }));
  });

  if (useLargest) {
    fits.sort(function (a, b) {
      return b.fitRatio - a.fitRatio;
    });
    return fits[0];
  }

  return fits.find(function (fit) {
    return fit.fitRatio >= 1;
  }) || fits[0];
} // This function takes a side and bunch of calculated dimensions from
// the portal, tooltip and target. Then it returns
// the percentage fit and the style to achieve this specific fit


function measureFit(_ref3) {
  var _style;

  var side = _ref3.side,
      align = _ref3.align,
      startKey = _ref3.startKey,
      lengthKey = _ref3.lengthKey,
      crossStartKey = _ref3.crossStartKey,
      crossLengthKey = _ref3.crossLengthKey,
      fromEnd = _ref3.fromEnd,
      portalDims = _ref3.portalDims,
      tooltipDims = _ref3.tooltipDims,
      anchorDims = _ref3.anchorDims;
  var parentStart = portalDims[startKey];
  var parentLength = portalDims[lengthKey];
  var crossParentStart = portalDims[crossStartKey];
  var crossParentLength = portalDims[crossLengthKey];
  var anchorStart = anchorDims[startKey] - portalDims[startKey];
  var anchorLength = anchorDims[lengthKey];
  var crossAnchorStart = anchorDims[crossStartKey];
  var crossAnchorLength = anchorDims[crossLengthKey];
  var crossAnchorWidth = anchorDims[crossLengthKey];
  var targetLength = tooltipDims[lengthKey];
  var crossTargetLength = tooltipDims[crossLengthKey];
  var targetStart;
  var fitRatio;

  if (!fromEnd) {
    targetStart = anchorStart - targetLength;
    fitRatio = Math.min(anchorStart / targetLength);
  } else {
    targetStart = anchorStart + anchorLength;
    fitRatio = (parentLength - (anchorStart + anchorLength)) / targetLength;
  }

  targetStart = Math.max(parentStart, Math.min(targetStart, parentLength));
  var crossTargetStart;

  if (startKey === 'left') {
    if (align === 'top') {
      align = 'start';
    } else if (align === 'bottom') {
      align = 'end';
    }
  } else {
    if (align === 'left') {
      align = 'start';
    } else if (align === 'right') {
      align = 'end';
    }
  }

  if (!['start', 'center', 'end'].includes(align)) {
    align = 'center';
  }

  if (align === 'start') {
    crossTargetStart = crossAnchorStart;
  } else if (align === 'end') {
    crossTargetStart = crossAnchorStart + crossAnchorWidth - crossTargetLength;
  } else {
    crossTargetStart = crossAnchorStart + crossAnchorLength / 2 - crossTargetLength / 2;
  }

  crossTargetStart = Math.max(crossParentStart, Math.min(crossTargetStart, crossParentLength - crossTargetLength));
  return {
    side: side,
    align: align,
    startKey: startKey,
    lengthKey: lengthKey,
    crossStartKey: crossStartKey,
    crossLengthKey: crossLengthKey,
    fromEnd: fromEnd,
    portalDims: portalDims,
    tooltipDims: tooltipDims,
    anchorDims: anchorDims,
    fitRatio: fitRatio,
    style: (_style = {}, _style[startKey] = targetStart, _style[crossStartKey] = crossTargetStart, _style)
  };
}

function usePrevious(val) {
  var ref = React__default.useRef();
  useIsomorphicLayoutEffect(function () {
    ref.current = val;
  }, [val]);
  return ref.current;
}

//

var showCount = 10;
var triangleSize = 7;

var getBackgroundColor$1 = function getBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';
};

function TooltipRenderer(props) {
  var _props$focusedDatum$g, _props$focusedDatum, _props$anchorFit$fit, _props$anchorFit$fit2, _focusedDatum$group, _focusedDatum$group2;

  if (!props.focusedDatum) {
    return null;
  }

  var primaryAxis = props.primaryAxis,
      secondaryAxis = props.secondaryAxis,
      getDatumStyle = props.getDatumStyle,
      focusedDatum = props.focusedDatum;

  var _props$getOptions = props.getOptions(),
      groupingMode = _props$getOptions.groupingMode,
      dark = _props$getOptions.dark;

  var groupDatums = (_props$focusedDatum$g = (_props$focusedDatum = props.focusedDatum) == null ? void 0 : _props$focusedDatum.group) != null ? _props$focusedDatum$g : [];
  var resolvedShowCount =  showCount ;
  var length = groupDatums.length; // Get the focused series' index

  var activeIndex = groupDatums.findIndex(function (d) {
    return d === focusedDatum;
  }); // Get the start by going back half of the showCount

  var start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0; // Make sure it's at least 0

  start = Math.max(start, 0); // Use the start and add the showCount to get the end

  var end = activeIndex > -1 ? start + resolvedShowCount : length; // Don't let the end go passed the length

  end = Math.min(end, length); // Double check we aren't clipping the start

  start = Math.max(end - resolvedShowCount, 0); // Slice the datums by start and end

  var visibleSortedGroupDatums = groupDatums.slice(start, end); // Detect if we have previous items

  var hasPrevious = start > 0; // Or next items

  var hasNext = end < length;
  var finalAlign = ((_props$anchorFit$fit = props.anchorFit.fit) == null ? void 0 : _props$anchorFit$fit.side) + "-" + ((_props$anchorFit$fit2 = props.anchorFit.fit) == null ? void 0 : _props$anchorFit$fit2.align);
  var arrowPosition;
  var triangleStyles;

  if (!arrowPosition) {
    if (finalAlign === 'left-center') {
      arrowPosition = 'right';
    } else if (finalAlign === 'right-center') {
      arrowPosition = 'left';
    } else if (finalAlign === 'top-center') {
      arrowPosition = 'bottom';
    } else if (finalAlign === 'bottom-center') {
      arrowPosition = 'top';
    } else if (finalAlign === 'right-start') {
      arrowPosition = 'bottomLeft';
    } else if (finalAlign === 'right-end') {
      arrowPosition = 'topLeft';
    } else if (finalAlign === 'left-start') {
      arrowPosition = 'bottomRight';
    } else if (finalAlign === 'left-end') {
      arrowPosition = 'topRight';
    }
  }

  var backgroundColor = getBackgroundColor$1(dark);

  if (arrowPosition === 'bottom') {
    triangleStyles = {
      top: '100%',
      left: '50%',
      transform: 'translate3d(-50%, 0%, 0)',
      borderLeft: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 0.8 + "px solid transparent",
      borderTop: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'top') {
    triangleStyles = {
      top: '0%',
      left: '50%',
      transform: 'translate3d(-50%, -100%, 0)',
      borderLeft: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'right') {
    triangleStyles = {
      top: '50%',
      left: '100%',
      transform: 'translate3d(0%, -50%, 0)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'left') {
    triangleStyles = {
      top: '50%',
      left: '0%',
      transform: 'translate3d(-100%, -50%, 0)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'topRight') {
    triangleStyles = {
      top: '0%',
      left: '100%',
      transform: 'translate3d(-50%, -50%, 0) rotate(-45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'bottomRight') {
    triangleStyles = {
      top: '100%',
      left: '100%',
      transform: 'translate3d(-50%, -50%, 0) rotate(45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'topLeft') {
    triangleStyles = {
      top: '0%',
      left: '0%',
      transform: 'translate3d(-50%, -50%, 0) rotate(45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (arrowPosition === 'bottomLeft') {
    triangleStyles = {
      top: '100%',
      left: '0%',
      transform: 'translate3d(-50%, -50%, 0) rotate(-45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else {
    triangleStyles = {
      opacity: 0
    };
  }

  return React__default.createElement("div", {
    style: {
      position: 'relative',
      fontSize: '10px',
      padding: '5px',
      background: getBackgroundColor$1(dark),
      color: dark ? 'black' : 'white',
      borderRadius: '3px'
    }
  }, React__default.createElement("div", {
    style: _extends({
      position: 'absolute',
      width: 0,
      height: 0
    }, triangleStyles)
  }), React__default.createElement("div", null, React__default.createElement("div", {
    style: {
      marginBottom: '3px',
      textAlign: 'center'
    }
  }, groupingMode === 'series' ? React__default.createElement("strong", null, focusedDatum.seriesLabel) : groupingMode === 'secondary' ? React__default.createElement("strong", null, secondaryAxis.formatters.tooltip(secondaryAxis.getValue(focusedDatum.originalDatum))) : React__default.createElement("strong", null, primaryAxis.formatters.tooltip(primaryAxis.getValue(focusedDatum.originalDatum)))), React__default.createElement("table", {
    style: {
      whiteSpace: 'nowrap'
    }
  }, React__default.createElement("tbody", null, hasPrevious ? React__default.createElement("tr", {
    style: {
      opacity: 0.8
    }
  }, React__default.createElement("td", null), React__default.createElement("td", null, "..."), React__default.createElement("td", null)) : null, visibleSortedGroupDatums.map(function (sortedDatum, i) {
    var active = sortedDatum === focusedDatum;
    return React__default.createElement("tr", {
      key: i,
      style: {
        opacity: active ? 1 : 0.8,
        fontWeight: active ? 'bold' : undefined
      }
    }, React__default.createElement("td", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }
    }, React__default.createElement("svg", {
      width: "14",
      height: "14"
    }, React__default.createElement("circle", {
      cx: "7",
      cy: "7",
      r: "5",
      style: _extends({}, getDatumStyle(sortedDatum), {
        stroke: dark ? 'black' : 'white',
        strokeWidth: active ? 2 : 1
      })
    }))), groupingMode === 'series' ? React__default.createElement(React__default.Fragment, null, React__default.createElement("td", null, primaryAxis.formatters.tooltip(primaryAxis.getValue(sortedDatum.originalDatum)), ": \xA0"), React__default.createElement("td", {
      style: {
        textAlign: 'right'
      }
    }, secondaryAxis.formatters.tooltip(secondaryAxis.getValue(sortedDatum.originalDatum)))) : groupingMode === 'secondary' ? React__default.createElement(React__default.Fragment, null, React__default.createElement("td", null, sortedDatum.seriesLabel, ": \xA0"), React__default.createElement("td", {
      style: {
        textAlign: 'right'
      }
    }, primaryAxis.formatters.tooltip(primaryAxis.getValue(sortedDatum.originalDatum)))) : React__default.createElement(React__default.Fragment, null, React__default.createElement("td", null, sortedDatum.seriesLabel, ": \xA0"), React__default.createElement("td", {
      style: {
        textAlign: 'right'
      }
    }, secondaryAxis.formatters.tooltip(secondaryAxis.getValue(sortedDatum.originalDatum)))));
  }), hasNext ? React__default.createElement("tr", {
    style: {
      opacity: 0.8
    }
  }, React__default.createElement("td", null), React__default.createElement("td", null, "..."), React__default.createElement("td", null)) : null, secondaryAxis.stacked && ((_focusedDatum$group = focusedDatum.group) != null ? _focusedDatum$group : []).length > 1 ? React__default.createElement("tr", null, React__default.createElement("td", {
    style: {
      paddingTop: '5px'
    }
  }, React__default.createElement("div", {
    style: {
      width: '12px',
      height: '12px',
      backgroundColor: dark ? 'rgba(0, 26, 39, 0.3)' : 'rgba(255,255,255,.2)',
      borderRadius: '50px'
    }
  })), React__default.createElement("td", {
    style: {
      paddingTop: '5px'
    }
  }, "Total: \xA0"), React__default.createElement("td", {
    style: {
      paddingTop: '5px'
    }
  }, sum((_focusedDatum$group2 = focusedDatum.group) != null ? _focusedDatum$group2 : [], function (d) {
    return secondaryAxis.getValue(d.originalDatum);
  }))) : null))));
}

function defaultTooltip(options) {
  var _options$align, _options$alignPriorit, _options$padding, _options$tooltipArrow, _options$render;

  if (options === void 0) {
    options = {};
  }

  return _extends({}, options, {
    align: (_options$align = options.align) != null ? _options$align : 'auto',
    alignPriority: (_options$alignPriorit = options.alignPriority) != null ? _options$alignPriorit : ['right', 'topRight', 'bottomRight', 'left', 'topLeft', 'bottomLeft', 'top', 'bottom'],
    padding: (_options$padding = options.padding) != null ? _options$padding : 5,
    tooltipArrowPadding: (_options$tooltipArrow = options.tooltipArrowPadding) != null ? _options$tooltipArrow : 7,
    // anchor: options.anchor ?? 'closest',
    render: (_options$render = options.render) != null ? _options$render : TooltipRenderer
  });
}

function Tooltip() {
  var _getOptions$tooltip, _secondaryAxes$find, _anchorRect$left, _anchorRect, _anchorRect$top, _anchorRect2, _anchorRect$width, _anchorRect3, _anchorRect$height, _anchorRect4, _anchorFit$fit;

  var _useChartContext = useChartContext(),
      useFocusedDatumAtom = _useChartContext.useFocusedDatumAtom,
      getOptions = _useChartContext.getOptions,
      primaryAxis = _useChartContext.primaryAxis,
      secondaryAxes = _useChartContext.secondaryAxes,
      getDatumStatusStyle = _useChartContext.getDatumStatusStyle;

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      focusedDatum = _useFocusedDatumAtom[0];

  var latestFocusedDatum = useLatestWhen(focusedDatum, !!focusedDatum);
  var preTooltipOptions = (_getOptions$tooltip = getOptions().tooltip) != null ? _getOptions$tooltip : true;
  var secondaryAxis = (_secondaryAxes$find = secondaryAxes.find(function (d) {
    return d.id === (latestFocusedDatum == null ? void 0 : latestFocusedDatum.secondaryAxisId);
  })) != null ? _secondaryAxes$find : secondaryAxes[0];
  var tooltipOptions = React__default.useMemo(function () {
    return defaultTooltip(typeof preTooltipOptions === 'boolean' ? {} : preTooltipOptions);
  }, [preTooltipOptions]);
  var anchorRect = null;

  if (latestFocusedDatum) {
    var _latestFocusedDatum$e, _latestFocusedDatum$e2;

    anchorRect = (_latestFocusedDatum$e = (_latestFocusedDatum$e2 = latestFocusedDatum.element) == null ? void 0 : _latestFocusedDatum$e2.getBoundingClientRect()) != null ? _latestFocusedDatum$e : null;
  }

  var portalEl = usePortalElement();

  var _React$useState = React__default.useState(),
      tooltipEl = _React$useState[0],
      setTooltipEl = _React$useState[1];

  var translateX = (_anchorRect$left = (_anchorRect = anchorRect) == null ? void 0 : _anchorRect.left) != null ? _anchorRect$left : 0;
  var translateY = (_anchorRect$top = (_anchorRect2 = anchorRect) == null ? void 0 : _anchorRect2.top) != null ? _anchorRect$top : 0;
  var width = (_anchorRect$width = (_anchorRect3 = anchorRect) == null ? void 0 : _anchorRect3.width) != null ? _anchorRect$width : 0;
  var height = (_anchorRect$height = (_anchorRect4 = anchorRect) == null ? void 0 : _anchorRect4.height) != null ? _anchorRect$height : 0;
  var boundingBox = React__default.useMemo(function () {
    var box = {
      x: translateY,
      y: translateX,
      top: translateY,
      left: translateX,
      bottom: translateY + width,
      right: translateX + height,
      width: width,
      height: height,
      toJSON: function toJSON() {
        return {};
      }
    };

    box.toJSON = function () {
      return box;
    };

    return box;
  }, [height, translateX, translateY, width]);
  var anchorEl = React__default.useMemo(function () {
    return {
      getBoundingClientRect: function getBoundingClientRect() {
        return boundingBox;
      }
    };
  }, [boundingBox]); // const isScrolling = useIsScrolling(200)

  var anchorFit = useAnchor({
    show: !!focusedDatum,
    portalEl: portalEl,
    anchorEl: anchorEl,
    tooltipEl: tooltipEl,
    side: ['right', 'left', 'top', 'bottom']
  });

  var _anchorFit$style = anchorFit.style,
      anchorFitStyle = _objectWithoutPropertiesLoose(_anchorFit$style, ["visibility"]);

  var previousFocusedDatum = usePrevious(focusedDatum);
  var previousAnchorFitStyle = usePrevious(anchorFitStyle);
  var wasZero = (previousAnchorFitStyle == null ? void 0 : previousAnchorFitStyle.left) === 0 && (previousAnchorFitStyle == null ? void 0 : previousAnchorFitStyle.top) === 0;
  var springProps = useSpring(_extends({}, anchorFitStyle, {
    opacity: wasZero ? 0 : focusedDatum && anchorFit.fit ? 1 : 0,
    config: {
      mass: 1,
      tension: 210,
      friction: 30
    },
    immediate: function immediate(key) {
      return (// isScrolling ||
        wasZero || ['left', 'top'].includes(key) && !previousFocusedDatum && !!focusedDatum
      );
    }
  }));
  var show = !!preTooltipOptions;
  return show && portalEl ? ReactDOM.createPortal(React__default.createElement(animated.div, {
    style: springProps
  }, React__default.createElement("div", {
    ref: function ref(el) {
      return setTooltipEl(el);
    },
    style: _extends({
      fontFamily: 'sans-serif'
    }, ((_anchorFit$fit = anchorFit.fit) == null ? void 0 : _anchorFit$fit.startKey) === 'left' ? {
      padding: '0 10px'
    } : {
      padding: '10px 0'
    })
  }, tooltipOptions.render({
    getOptions: getOptions,
    focusedDatum: latestFocusedDatum,
    primaryAxis: primaryAxis,
    secondaryAxis: secondaryAxis,
    getDatumStyle: function getDatumStyle(datum) {
      return getDatumStatusStyle(datum, focusedDatum);
    },
    anchorFit: anchorFit
  }))), portalEl) : null;
}

function Voronoi() {
  var _useChartContext = useChartContext(),
      getOptions = _useChartContext.getOptions,
      useFocusedDatumAtom = _useChartContext.useFocusedDatumAtom;

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      setFocusedDatum = _useFocusedDatumAtom[1];

  var _getOptions = getOptions(),
      onFocusDatum = _getOptions.onFocusDatum,
      onClickDatum = _getOptions.onClickDatum,
      tooltip = _getOptions.tooltip,
      primaryCursor = _getOptions.primaryCursor,
      secondaryCursor = _getOptions.secondaryCursor,
      showVoronoi = _getOptions.showVoronoi,
      groupingMode = _getOptions.groupingMode;

  var handleFocus = React__default.useCallback(function (datum) {
    onFocusDatum == null ? void 0 : onFocusDatum(datum);
    setFocusedDatum(datum);
  }, [onFocusDatum, setFocusedDatum]);
  var needsVoronoi = onFocusDatum || onClickDatum || tooltip || primaryCursor || secondaryCursor || showVoronoi; // Don't render until we have all dependencies

  if (!needsVoronoi) {
    return null;
  }

  var props = {
    handleFocus: handleFocus
  };

  if (groupingMode === 'primary') {
    return React__default.createElement(PrimaryVoronoi, _extends({}, props));
  }

  return null; // return <ClosestVoronoi {...props} />
}

function PrimaryVoronoi(_ref) {
  var handleFocus = _ref.handleFocus;

  var _useChartContext2 = useChartContext(),
      primaryAxis = _useChartContext2.primaryAxis,
      series = _useChartContext2.series,
      secondaryAxes = _useChartContext2.secondaryAxes,
      getOptions = _useChartContext2.getOptions,
      gridDimensions = _useChartContext2.gridDimensions,
      groupedDatums = _useChartContext2.groupedDatums;

  return React__default.useMemo(function () {
    var columns = series[0].datums.map(function (datum, i) {
      var _primaryAxis$scale, _primaryAxis$scale$ra, _groupedDatums$get;

      var prev = series[0].datums[i - 1];
      var next = series[0].datums[i + 1];
      var primaryValue = primaryAxis.getValue(datum.originalDatum);
      var primaryPx = (_primaryAxis$scale = primaryAxis == null ? void 0 : primaryAxis.scale(primaryValue)) != null ? _primaryAxis$scale : NaN;
      var range = (_primaryAxis$scale$ra = primaryAxis == null ? void 0 : primaryAxis.scale.range()) != null ? _primaryAxis$scale$ra : [0, 0];

      if (primaryAxis != null && primaryAxis.isVertical) {
        range.reverse();
      }

      var primaryStart = range[0],
          primaryEnd = range[1];

      if (prev) {
        var _primaryAxis$scale2;

        var prevPx = (_primaryAxis$scale2 = primaryAxis == null ? void 0 : primaryAxis.scale(primaryAxis.getValue(prev.originalDatum))) != null ? _primaryAxis$scale2 : NaN;
        primaryStart = primaryPx - (primaryPx - prevPx) / 2;
      }

      if (next) {
        var _primaryAxis$scale3;

        var nextPx = (_primaryAxis$scale3 = primaryAxis == null ? void 0 : primaryAxis.scale(primaryAxis.getValue(next.originalDatum))) != null ? _primaryAxis$scale3 : NaN;
        primaryEnd = primaryPx + (nextPx - primaryPx) / 2;
      }

      var datums = (_groupedDatums$get = groupedDatums.get("" + primaryValue)) != null ? _groupedDatums$get : [];
      datums.sort(function (a, b) {
        var _aAxis$scale, _a$stackData, _bAxis$scale, _b$stackData;

        var aAxis = secondaryAxes.find(function (d) {
          return d.id === a.secondaryAxisId;
        });
        var bAxis = secondaryAxes.find(function (d) {
          return d.id === b.secondaryAxisId;
        });
        var aPx = (_aAxis$scale = aAxis == null ? void 0 : aAxis.scale(aAxis.stacked ? (_a$stackData = a.stackData) == null ? void 0 : _a$stackData[1] : aAxis == null ? void 0 : aAxis.getValue(a.originalDatum))) != null ? _aAxis$scale : NaN;
        var bPx = (_bAxis$scale = bAxis == null ? void 0 : bAxis.scale(bAxis.stacked ? (_b$stackData = b.stackData) == null ? void 0 : _b$stackData[1] : bAxis == null ? void 0 : bAxis.getValue(b.originalDatum))) != null ? _bAxis$scale : NaN;
        return aPx - bPx;
      });
      return {
        primaryStart: primaryStart,
        primaryEnd: primaryEnd,
        primaryPx: primaryPx,
        datumBoundaries: datums.map(function (datum, i) {
          var _secondaryAxis$scale3, _secondaryAxis$scale$2;

          var prev = datums[i - 1];
          var next = datums[i + 1];
          var secondaryAxis = secondaryAxes.find(function (d) {
            return d.id === datum.secondaryAxisId;
          });

          if (secondaryAxis != null && secondaryAxis.stacked) {
            var _secondaryAxis$scale$;

            var _range = (_secondaryAxis$scale$ = secondaryAxis == null ? void 0 : secondaryAxis.scale.range()) != null ? _secondaryAxis$scale$ : [0, 0];

            if (secondaryAxis != null && secondaryAxis.isVertical) {
              _range.reverse();
            }

            var _secondaryStart = _range[0],
                _secondaryEnd = _range[1];

            if (prev) {
              var _secondaryAxis$scale, _datum$stackData$, _datum$stackData;

              _secondaryStart = (_secondaryAxis$scale = secondaryAxis == null ? void 0 : secondaryAxis.scale((_datum$stackData$ = (_datum$stackData = datum.stackData) == null ? void 0 : _datum$stackData[1]) != null ? _datum$stackData$ : NaN)) != null ? _secondaryAxis$scale : NaN;
            }

            if (next) {
              var _secondaryAxis$scale2, _datum$stackData$2, _datum$stackData2;

              _secondaryEnd = (_secondaryAxis$scale2 = secondaryAxis == null ? void 0 : secondaryAxis.scale((_datum$stackData$2 = (_datum$stackData2 = datum.stackData) == null ? void 0 : _datum$stackData2[0]) != null ? _datum$stackData$2 : NaN)) != null ? _secondaryAxis$scale2 : NaN;
            }

            return {
              secondaryStart: _secondaryStart,
              secondaryEnd: _secondaryEnd,
              datum: datum
            };
          }

          var value = (_secondaryAxis$scale3 = secondaryAxis == null ? void 0 : secondaryAxis.scale(secondaryAxis == null ? void 0 : secondaryAxis.getValue(datum.originalDatum))) != null ? _secondaryAxis$scale3 : NaN;
          var range = (_secondaryAxis$scale$2 = secondaryAxis == null ? void 0 : secondaryAxis.scale.range()) != null ? _secondaryAxis$scale$2 : [0, 0];

          if (secondaryAxis != null && secondaryAxis.isVertical) {
            range.reverse();
          }

          var secondaryStart = range[0],
              secondaryEnd = range[1];

          if (prev) {
            var _prevAxis$scale;

            var prevAxis = secondaryAxes.find(function (d) {
              return d.id === (prev == null ? void 0 : prev.secondaryAxisId);
            });
            var prevValue = (_prevAxis$scale = prevAxis == null ? void 0 : prevAxis.scale(prevAxis == null ? void 0 : prevAxis.getValue(prev.originalDatum))) != null ? _prevAxis$scale : NaN;
            secondaryStart = value - (value - prevValue) / 2;
          }

          if (next) {
            var _nextAxis$scale;

            var nextAxis = secondaryAxes.find(function (d) {
              return d.id === (next == null ? void 0 : next.secondaryAxisId);
            });
            var nextValue = (_nextAxis$scale = nextAxis == null ? void 0 : nextAxis.scale(nextAxis == null ? void 0 : nextAxis.getValue(next.originalDatum))) != null ? _nextAxis$scale : NaN;
            secondaryEnd = value + (nextValue - value) / 2;
          }

          return {
            secondaryStart: secondaryStart,
            secondaryEnd: secondaryEnd,
            datum: datum
          };
        })
      };
    });
    return React__default.createElement("g", _extends({}, {
      onMouseLeave: function onMouseLeave() {
        return handleFocus(null);
      },
      style: {
        transform: translate(gridDimensions.gridX, gridDimensions.gridY)
      }
    }), columns.map(function (column) {
      return React__default.createElement(React__default.Fragment, {
        key: column.primaryPx
      }, column.datumBoundaries.map(function (datumBoundary) {
        var x1 = !primaryAxis.isVertical ? column.primaryStart : datumBoundary.secondaryStart;
        var x2 = !primaryAxis.isVertical ? column.primaryEnd : datumBoundary.secondaryEnd;
        var y1 = !primaryAxis.isVertical ? datumBoundary.secondaryStart : column.primaryStart;
        var y2 = !primaryAxis.isVertical ? datumBoundary.secondaryEnd : column.primaryEnd;
        var x = Math.min(x1, x2);
        var y = Math.min(y1, y2);
        var xEnd = Math.max(x1, x2);
        var yEnd = Math.max(y1, y2);
        var height = Math.max(yEnd - y, 0);
        var width = Math.max(xEnd - x, 0);
        return React__default.createElement("rect", _extends({}, {
          key: column.primaryPx + "_" + datumBoundary.datum.seriesIndex,
          x: x,
          y: y,
          width: width,
          height: height,
          className: 'action-voronoi',
          onMouseEnter: function onMouseEnter() {
            return handleFocus(datumBoundary.datum);
          },
          style: {
            fill: randomFill(),
            opacity: getOptions().showVoronoi ? 1 : 0
          }
        }));
      }));
    }));
  }, [getOptions, gridDimensions.gridX, gridDimensions.gridY, groupedDatums, handleFocus, primaryAxis, secondaryAxes, series]);
} // function ClosestVoronoi({
//   stackData,
//   extent,
//   handleFocus,
//   showVoronoi,
// }: {
//   stackData: Series[]
//   extent: number[][]
//   handleFocus: (datum: Datum | null) => void
//   showVoronoi: boolean
// }) {
//   let polygons = null
//   const voronoiData: { x: number; y: number; datum: Datum }[] = []
//   stackData.forEach(series => {
//     series.datums
//       .filter(d => d.defined)
//       .forEach(datum => {
//         datum.boundingPoints.forEach(boundingPoint => {
//           if (
//             typeof datum.x !== 'number' ||
//             typeof datum.y !== 'number' ||
//             Number.isNaN(datum.y) ||
//             Number.isNaN(datum.x)
//           ) {
//             return
//           }
//           voronoiData.push({
//             x: boundingPoint.x,
//             y: boundingPoint.y,
//             datum,
//           })
//         })
//       })
//   })
//   const delaunay = Delaunay.from(
//     voronoiData,
//     d => Math.max(d.x, 0),
//     d => Math.max(d.y, 0)
//   )
//   const flatExtent = extent.flat().map(d => Math.max(d, 0))
//   const voronoi = delaunay.voronoi(flatExtent)
//   polygons = voronoi.cellPolygons()
//   polygons = Array.from(polygons)
//   return (
//     <g>
//       {polygons.map((points, i) => {
//         const index = points.index
//         const datum = voronoiData[index].datum
//         const path = lineFn(points as any) || undefined
//         return (
//           <Path
//             key={i}
//             d={path}
//             className="action-voronoi"
//             onMouseEnter={() => handleFocus(datum)}
//             onMouseLeave={() => handleFocus(null)}
//             style={{
//               fill: randomFill(),
//               opacity: showVoronoi ? 1 : 0,
//             }}
//           />
//         )
//       })}
//     </g>
//   )
// }


function randomFill() {
  var r = randomHue(100, 200);
  var g = randomHue(0, r);
  var b = randomHue(0, g);
  var colors = shuffle([r, g, b]);
  return "rgba(" + colors.join(', ') + ", .5)";
}

function randomHue(min, max) {
  if (min === void 0) {
    min = 0;
  }

  if (max === void 0) {
    max = 255;
  }

  return Math.floor(min + Math.random() * Math.min(max, 255 - min));
}

function shuffle(array) {
  var currentIndex = array.length,
      randomIndex; // While there remain elements to shuffle...

  while (0 !== currentIndex) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    var _ref2 = [array[randomIndex], array[currentIndex]];
    array[currentIndex] = _ref2[0];
    array[randomIndex] = _ref2[1];
  }

  return array;
}

//

var defaultColorScheme = ['#0f83ab', '#faa43a', '#ff4e4e', '#53cfc9', '#a2d925', '#decf3f', '#734fe9', '#cd82ad', '#006d92', '#de7c00', '#f33232', '#3f9a80', '#53c200', '#d7af00', '#4c26c9', '#d44d99'];

function defaultChartOptions(options) {
  var _options$initialWidth, _options$initialHeigh, _options$getSeriesSty, _options$getDatumStyl, _options$getSeriesOrd, _options$groupingMode, _options$showVoronoi, _options$defaultColor;

  return _extends({}, options, {
    initialWidth: (_options$initialWidth = options.initialWidth) != null ? _options$initialWidth : 300,
    initialHeight: (_options$initialHeigh = options.initialHeight) != null ? _options$initialHeigh : 200,
    getSeriesStyle: (_options$getSeriesSty = options.getSeriesStyle) != null ? _options$getSeriesSty : function () {
      return {};
    },
    getDatumStyle: (_options$getDatumStyl = options.getDatumStyle) != null ? _options$getDatumStyl : function () {
      return {};
    },
    getSeriesOrder: (_options$getSeriesOrd = options.getSeriesOrder) != null ? _options$getSeriesOrd : function (series) {
      return series;
    },
    groupingMode: (_options$groupingMode = options.groupingMode) != null ? _options$groupingMode : 'primary',
    showVoronoi: (_options$showVoronoi = options.showVoronoi) != null ? _options$showVoronoi : false,
    defaultColors: (_options$defaultColor = options.defaultColors) != null ? _options$defaultColor : defaultColorScheme
  });
}

function Chart(_ref) {
  var userOptions = _ref.options,
      className = _ref.className,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      rest = _objectWithoutPropertiesLoose(_ref, ["options", "className", "style"]);

  var options = defaultChartOptions(userOptions);

  var _React$useState = React__default.useState(null),
      containerElement = _React$useState[0],
      setContainerElement = _React$useState[1];

  var parentElement = containerElement == null ? void 0 : containerElement.parentElement;

  var _useRect = useRect(parentElement, options),
      width = _useRect.width,
      height = _useRect.height;

  useIsomorphicLayoutEffect(function () {
    if (parentElement) {
      var computed = window.getComputedStyle(parentElement);

      if (!['relative', 'absolute', 'fixed'].includes(computed.display)) {
        parentElement.style.position = 'relative';
      }
    }
  }, [parentElement]);
  return React__default.createElement("div", _extends({
    ref: setContainerElement
  }, rest, {
    className: "ReactChart " + (className || ''),
    style: _extends({}, style, {
      position: 'absolute',
      width: width,
      height: height
    })
  }), React__default.createElement(ChartInner, _extends({
    options: options
  }, {
    width: width,
    height: height
  })));
}

function ChartInner(_ref2) {
  var _options$renderSVG;

  var options = _ref2.options,
      width = _ref2.width,
      height = _ref2.height;

  if (!options.primaryAxis) {
    throw new Error('A primaryAxis is required');
  }

  if (!options.secondaryAxes.length) {
    throw new Error('At least one secondaryAxis is required');
  }

  var svgRef = React__default.useRef(null);
  var svgRect = useRect(svgRef.current);
  var getOptions = useGetLatest(options);
  var axisDimensionsAtom = React__default.useMemo(function () {
    return atom({
      left: {},
      right: {},
      top: {},
      bottom: {}
    });
  }, []);
  var focusedDatumAtom = React__default.useMemo(function () {
    return atom(null);
  }, []);
  var useAxisDimensionsAtom = React__default.useCallback(function () {
    // eslint-disable-next-line
    return useAtom(axisDimensionsAtom);
  }, [axisDimensionsAtom]);
  var useFocusedDatumAtom = React__default.useCallback(function () {
    // eslint-disable-next-line
    return useAtom(focusedDatumAtom);
  }, [focusedDatumAtom]); // useAtom<Datum<TDatum> | null>(focusedDatumAtom)

  var _useAxisDimensionsAto = useAxisDimensionsAtom(),
      axisDimensions = _useAxisDimensionsAto[0];

  var _useFocusedDatumAtom = useFocusedDatumAtom(),
      focusedDatum = _useFocusedDatumAtom[0];

  var gridDimensions = React__default.useMemo(function () {
    // Left
    var _map = ['width', 'top', 'bottom'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.left, prop);
    }),
        axesLeftWidth = _map[0],
        axesLeftTop = _map[1],
        axesLeftBottom = _map[2];

    var _map2 = ['width', 'top', 'bottom'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.right, prop);
    }),
        axesRightWidth = _map2[0],
        axesRightTop = _map2[1],
        axesRightBottom = _map2[2];

    var _map3 = ['height', 'left', 'right'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.top, prop);
    }),
        axesTopHeight = _map3[0],
        axesTopLeft = _map3[1],
        axesTopRight = _map3[2];

    var _map4 = ['height', 'left', 'right'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.bottom, prop);
    }),
        axesBottomHeight = _map4[0],
        axesBottomLeft = _map4[1],
        axesBottomRight = _map4[2];

    var gridX = Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft);
    var gridY = Math.max(axesTopHeight, axesLeftTop, axesRightTop);
    var gridWidth = Math.max(0, width - Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) - Math.max(axesRightWidth, axesTopRight, axesBottomRight));
    var gridHeight = Math.max(0, height - Math.max(axesTopHeight, axesLeftTop, axesRightTop) - Math.max(axesBottomHeight, axesLeftBottom, axesRightBottom));
    return {
      gridX: gridX,
      gridY: gridY,
      gridWidth: gridWidth,
      gridHeight: gridHeight
    };
  }, [width, height, axisDimensions]);
  var series = React__default.useMemo(function () {
    var series = [];

    for (var seriesIndex = 0; seriesIndex < options.data.length; seriesIndex++) {
      var _originalSeries$id, _originalSeries$label;

      var originalSeries = options.data[seriesIndex];
      var seriesId = (_originalSeries$id = originalSeries.id) != null ? _originalSeries$id : seriesIndex + '';
      var seriesLabel = (_originalSeries$label = originalSeries.label) != null ? _originalSeries$label : "Series " + (seriesIndex + 1);
      var secondaryAxisId = originalSeries.secondaryAxisId;
      var originalDatums = originalSeries.data;
      var datums = [];

      for (var datumIndex = 0; datumIndex < originalDatums.length; datumIndex++) {
        var originalDatum = originalDatums[datumIndex];
        datums[datumIndex] = {
          originalSeries: originalSeries,
          seriesIndex: seriesIndex,
          seriesId: seriesId,
          seriesLabel: seriesLabel,
          secondaryAxisId: secondaryAxisId,
          index: datumIndex,
          originalDatum: originalDatum
        };
      }

      series[seriesIndex] = {
        originalSeries: originalSeries,
        index: seriesIndex,
        id: seriesId,
        label: seriesLabel,
        secondaryAxisId: secondaryAxisId,
        datums: datums
      };
    }

    if (options.secondaryAxes.some(function (axisOptions) {
      return axisOptions.stacked;
    })) {
      options.secondaryAxes.filter(function (d) {
        return d.stacked;
      }).forEach(function (secondaryAxis) {
        var _secondaryAxis$stackO;

        var axisSeries = series.filter(function (s) {
          return s.secondaryAxisId === secondaryAxis.id;
        });
        var seriesIndices = Object.keys(axisSeries);
        var stacker = stack().keys(seriesIndices).value(function (_, seriesIndex, index) {
          var val = secondaryAxis.getValue(axisSeries[Number(seriesIndex)].datums[index].originalDatum);

          if (typeof val === 'undefined' || val === null) {
            return 0;
          }

          return val;
        }).offset((_secondaryAxis$stackO = secondaryAxis.stackOffset) != null ? _secondaryAxis$stackO : stackOffsetNone);
        var stacked = stacker(Array.from({
          length: axisSeries.sort(function (a, b) {
            return b.datums.length - a.datums.length;
          })[0].datums.length
        }));
        stacked.forEach(function (s, sIndex) {
          s.forEach(function (datum, i) {
            // @ts-ignore
            datum.data = axisSeries[sIndex].datums[i];
            axisSeries[sIndex].datums[i].stackData = datum;
          });
        });
      });
    }

    return series;
  }, [options.data, options.secondaryAxes]);
  var primaryAxis = React__default.useMemo(function () {
    return buildAxisLinear(options.primaryAxis, series, gridDimensions, width, height);
  }, [gridDimensions, height, options.primaryAxis, series, width]);
  var secondaryAxes = React__default.useMemo(function () {
    return options.secondaryAxes.map(function (secondaryAxis) {
      return buildAxisLinear(secondaryAxis, series, gridDimensions, width, height);
    });
  }, [gridDimensions, height, options.secondaryAxes, series, width]);
  var axesInfo = React__default.useMemo(function () {
    // Make sure we're mapping x and y to the correct axes
    var xKey = primaryAxis.isVertical ? 'secondary' : 'primary';
    var yKey = primaryAxis.isVertical ? 'primary' : 'secondary';
    return {
      xKey: xKey,
      yKey: yKey
    };
  }, [primaryAxis]);
  var groupedDatums = React__default.useMemo(function () {
    var groupedDatums = new Map();
    var allDatums = series.map(function (s) {
      return s.datums;
    }).flat(2);
    allDatums.forEach(function (datum) {
      var primaryValue = "" + primaryAxis.getValue(datum.originalDatum);

      if (!groupedDatums.has(primaryValue)) {
        groupedDatums.set(primaryValue, []);
      }

      groupedDatums.get(primaryValue).push(datum);
    });
    allDatums.forEach(function (datum) {
      var primaryValue = "" + primaryAxis.getValue(datum.originalDatum);
      datum.group = groupedDatums.get(primaryValue);
    });
    return groupedDatums;
  }, [primaryAxis, series]);
  var getSeriesStatusStyle = React__default.useCallback(function (series, focusedDatum) {
    var base = {
      color: getOptions().defaultColors[series.index % (getOptions().defaultColors.length - 1)]
    };
    var status = getSeriesStatus(series, focusedDatum);
    var statusStyles = getOptions().getSeriesStyle(series, status);
    series.style = materializeStyles(statusStyles, base);
    return series.style;
  }, [getOptions]);
  var getDatumStatusStyle = React__default.useCallback(function (datum, focusedDatum) {
    var base = _extends({}, series[datum.seriesIndex].style, {
      color: getOptions().defaultColors[datum.seriesIndex % (getOptions().defaultColors.length - 1)]
    });

    var status = getDatumStatus(datum, focusedDatum);
    var statusStyles = getOptions().getDatumStyle(datum, status);
    datum.style = materializeStyles(statusStyles, base);
    return datum.style;
  }, [getOptions, series]); // const mouseMoveRafRef = React.useRef<number | null>()
  // const onMouseMove = (
  //   e: React.MouseEvent<SVGSVGElement, MouseEvent> | MouseEvent
  // ) => {
  //   if (mouseMoveRafRef.current) {
  //     Raf.cancel(mouseMoveRafRef.current)
  //   }
  //   mouseMoveRafRef.current = Raf(() => {
  //     mouseMoveRafRef.current = null
  //     const { clientX, clientY } = e
  //     setPointer(old => {
  //       const x = clientX - svgRect.left - gridDimensions.gridX
  //       const y = clientY - svgRect.top - gridDimensions.gridY
  //       return {
  //         ...old,
  //         svgHovered: true,
  //         x,
  //         y,
  //       }
  //     })
  //   })
  // }
  // const onMouseUp = () => {
  //   document.removeEventListener('mouseup', onMouseUp)
  //   document.removeEventListener('mousemove', onMouseMove)
  //   // if (options.brush?.onSelect && pointer.dragging) {
  //   //   if (Math.abs(pointer.startX - pointer.x) >= 20) {
  //   //     options.brush.onSelect({
  //   //       pointer,
  //   //       start: (axesInfo.primaryAxes[0].scale as ScaleLinear<
  //   //         number,
  //   //         number
  //   //       >).invert(pointer.startX),
  //   //       end: (axesInfo.primaryAxes[0].scale as ScaleLinear<
  //   //         number,
  //   //         number
  //   //       >).invert(pointer.x),
  //   //     })
  //   //   }
  //   // }
  //   setPointer(
  //     (old): Pointer => {
  //       return {
  //         ...old,
  //         dragging: false,
  //       }
  //     }
  //   )
  // }
  // const onMouseDown = () => {
  //   document.addEventListener('mouseup', onMouseUp)
  //   document.addEventListener('mousemove', onMouseMove)
  //   setPointer(
  //     (old): Pointer => {
  //       return {
  //         ...old,
  //         startX: old.x,
  //         startY: old.y,
  //         dragging: true,
  //       }
  //     }
  //   )
  // }
  // Reverse the stack order for proper z-indexing

  var reversedSeries = [].concat(series).reverse();
  var orderedSeries = options.getSeriesOrder(reversedSeries); // const focusedSeriesIndex = focusedDatum
  //   ? orderedSeries.findIndex(series => series.id === focusedDatum.seriesId)
  //   : -1
  // Bring focused series to the front
  // orderedSeries = focusedDatum
  //   ? [
  //       ...orderedSeries.slice(0, focusedSeriesIndex),
  //       ...orderedSeries.slice(focusedSeriesIndex + 1),
  //       orderedSeries[focusedSeriesIndex],
  //     ]
  //   : orderedSeries

  useIsomorphicLayoutEffect(function () {
    if (svgRef.current && svgRef.current.parentElement && !svgRef.current.parentElement.style.position) {
      svgRef.current.parentElement.style.position = 'relative';
    }
  });
  var contextValue = {
    getOptions: getOptions,
    gridDimensions: gridDimensions,
    primaryAxis: primaryAxis,
    secondaryAxes: secondaryAxes,
    axesInfo: axesInfo,
    series: series,
    orderedSeries: orderedSeries,
    groupedDatums: groupedDatums,
    width: width,
    height: height,
    getSeriesStatusStyle: getSeriesStatusStyle,
    getDatumStatusStyle: getDatumStatusStyle,
    useAxisDimensionsAtom: useAxisDimensionsAtom,
    useFocusedDatumAtom: useFocusedDatumAtom,
    svgRect: svgRect
  };
  var seriesByAxisId = sort(groups(orderedSeries, function (d) {
    return d.secondaryAxisId;
  }), function (_ref3) {
    var key = _ref3[0];
    return secondaryAxes.findIndex(function (axis) {
      return axis.id === key;
    });
  });
  return React__default.createElement(ChartContextProvider, {
    value: useGetLatest(contextValue)
  }, React__default.createElement("div", {
    style: {
      fontFamily: 'sans-serif'
    }
  }, React__default.createElement("svg", {
    ref: svgRef,
    style: {
      width: width,
      height: height,
      overflow: options.brush ? 'hidden' : 'visible'
    },
    // onMouseEnter={e => {
    //   e.persist()
    //   onMouseMove(e)
    // }}
    // onMouseMove={e => {
    //   e.persist()
    //   onMouseMove(e)
    // }}
    // onMouseLeave={e => {
    //   e.persist()
    //   setPointer(old => {
    //     return {
    //       ...old,
    //       svgHovered: false,
    //     }
    //   })
    // }}
    // onMouseDown={e => {
    //   e.persist()
    //   onMouseDown()
    // }}
    onClick: function onClick(e) {
      return options.onClickDatum == null ? void 0 : options.onClickDatum(focusedDatum, e);
    }
  }, React__default.createElement("g", {
    className: "Series",
    style: {
      pointerEvents: 'none'
    }
  }, seriesByAxisId.map(function (_ref4) {
    var axisId = _ref4[0],
        series = _ref4[1];
    var secondaryAxis = secondaryAxes.find(function (d) {
      return d.id === axisId;
    });

    if (!secondaryAxis) {
      return null;
    }

    var elementType = secondaryAxis.elementType;

    var Component = function () {
      if (elementType === 'line') {
        return Line;
      }

      if (elementType === 'bar') {
        return BarComponent;
      }

      if (elementType === 'area') {
        return AreaComponent;
      }

      throw new Error('Invalid elementType');
    }();

    return React__default.createElement(Component, {
      key: axisId != null ? axisId : '__default__',
      primaryAxis: primaryAxis,
      secondaryAxis: secondaryAxis,
      series: series
    });
  })), React__default.createElement("g", {
    className: "axes"
  }, [primaryAxis].concat(secondaryAxes).map(function (axis) {
    return React__default.createElement(AxisLinearComp, _extends({
      key: [axis.position, axis.id].join('')
    }, axis));
  })), React__default.createElement(Voronoi, null), (_options$renderSVG = options.renderSVG == null ? void 0 : options.renderSVG()) != null ? _options$renderSVG : null), React__default.createElement(Cursors, null), React__default.createElement(Tooltip, null)));
}

function sumAllDimensionProperties(axisDimensions, side) {
  var sum = 0;
  Object.keys(axisDimensions).forEach(function (axisId) {
    var _axisDimensions$axisI;

    sum += ((_axisDimensions$axisI = axisDimensions[axisId]) == null ? void 0 : _axisDimensions$axisI[side]) || 0;
  });
  return sum;
}

export { Chart };
//# sourceMappingURL=react-charts.esm.js.map
