import _toConsumableArray from "reshow-runtime/es/helpers/toConsumableArray";
import callfunc from "call-func";
import { UNDEFINED, T_UNDEFINED } from "reshow-constant";

var emitter = function emitter() {
  var pool = [];
  return {
    reset: function reset() {
      return pool.splice(0, pool.length);
    },
    add: function add(handler) {
      return pool.unshift(handler);
    },
    // >>> 0 for change indexOf return -1 to 4294967295
    remove: function remove(handler) {
      return pool.splice(pool.indexOf(handler) >>> 0, 1);
    },
    emit: function emit(state, action, prevState) {
      return setTimeout(function () {
        var i = pool.length;

        while (i--) {
          var func = pool[i];
          func && func(state, action, prevState);
        }
      });
    }
  };
};
/**
 * Transpile dispatch("your-type", {foo: "bar"})
 * to dispatch({type: "your-type", params: {foo: "bar"}})
 */


var refineAction = function refineAction() {
  var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params = arguments.length > 1 ? arguments[1] : undefined;

  if (action.trim) {
    action = {
      type: action
    };
    params && (action.params = params);
  }

  return action;
};

var createReducer = function createReducer(reduce) {
  var initState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var state = {
    current: callfunc(initState)
  };
  var mitt = emitter();

  var dispatch = function dispatch() {
    for (var _len = arguments.length, action = new Array(_len), _key = 0; _key < _len; _key++) {
      action[_key] = arguments[_key];
    }

    action = refineAction.apply(void 0, _toConsumableArray(action));
    var startingState = state.current;
    var endingState = reduce(startingState, action);

    if (endingState === T_UNDEFINED) {
      console.trace();
      throw "reduce() return ".concat(UNDEFINED, ".");
    }

    if (startingState !== endingState) {
      state.current = endingState;
      mitt.emit(endingState, action, startingState);
    }
  };

  var store = {
    reset: function reset() {
      return mitt.reset() && callfunc(initState);
    },
    getState: function getState() {
      return state.current;
    },
    addListener: mitt.add,
    removeListener: mitt.remove
  };
  return [store, dispatch];
};

export default createReducer;
export { refineAction };