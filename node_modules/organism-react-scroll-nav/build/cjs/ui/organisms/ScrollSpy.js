"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.weak-map.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.get-own-property-descriptor.js");

var _interopRequireDefault = require("reshow-runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("reshow-runtime/helpers/objectSpread2"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("reshow-runtime/helpers/objectWithoutPropertiesLoose"));

var _react = _interopRequireWildcard(require("react"));

var _getObjectValue = _interopRequireDefault(require("get-object-value"));

var _reactAtomicMolecule = require("react-atomic-molecule");

var _reshowHooks = require("reshow-hooks");

var _scrollStore = _interopRequireDefault(require("../../src/stores/scrollStore"));

var _fastScrollStore = _interopRequireDefault(require("../../src/stores/fastScrollStore"));

var _excluded = ["noDelay", "monitorScroll", "id", "scrollMargin", "children", "container", "className", "attachTo"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var useScrollSpy = function useScrollSpy(props) {
  /**
   * monitorScroll use in store, in component just for reset props.
   */
  var _props$noDelay = props.noDelay,
      noDelay = _props$noDelay === void 0 ? false : _props$noDelay,
      _props$monitorScroll = props.monitorScroll,
      monitorScroll = _props$monitorScroll === void 0 ? true : _props$monitorScroll,
      id = props.id,
      scrollMargin = props.scrollMargin,
      children = props.children,
      container = props.container,
      className = props.className,
      attachTo = props.attachTo,
      others = (0, _objectWithoutPropertiesLoose2["default"])(props, _excluded);

  var _useState = (0, _react.useState)(id),
      targetId = _useState[0],
      setTargetId = _useState[1];

  var lastEl = (0, _react.useRef)();
  var lastConfig = (0, _react.useRef)({});
  lastConfig.current = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, lastConfig.current), {}, {
    id: targetId,
    attachTo: attachTo,
    monitorScroll: monitorScroll,
    scrollMargin: scrollMargin
  });
  var thisClassName = (0, _react.useMemo)(function () {
    return (0, _reactAtomicMolecule.mixClass)(className, "spy-tar-" + targetId);
  }, [targetId, className]);
  (0, _react.useEffect)(function () {
    var store = noDelay ? _fastScrollStore["default"] : _scrollStore["default"];
    var id = store.scroller.attach(expose);
    setTargetId(id);
    return function () {
      store.scroller.detach(expose);
    };
  }, []);
  var warnDebounce = (0, _reshowHooks.useDebounce)(function (args) {
    // for lazy render component, that warn delay 1 secs.
    if (!lastEl.current) {
      console.warn('Please use SemanticUI. props.container -> import {SemanticUI} from "react-atomic-molecule"', args);
    }
  }, 1000);
  var getOffsetEl = (0, _react.useCallback)(function () {
    if (lastEl.current) {
      return lastEl.current;
    } else {
      warnDebounce({
        thisClassName: thisClassName,
        nextContainer: nextContainer
      });
    }
  }, [thisClassName, nextContainer]);
  var expose = {
    getOffsetEl: getOffsetEl,
    getId: function getId() {
      return lastConfig.current.id;
    },
    setId: setTargetId,
    getAttachTo: function getAttachTo() {
      return lastConfig.current.attachTo;
    },
    setAttachTo: function setAttachTo(attachTo) {
      return lastConfig.current.attachTo = attachTo;
    },
    getMonitorScroll: function getMonitorScroll() {
      return lastConfig.current.monitorScroll;
    },
    getScrollMargin: function getScrollMargin() {
      return lastConfig.current.scrollMargin;
    }
  };
  var hasScrollReceiver = (0, _react.useMemo)(function () {
    return "ScrollReceiver" === (0, _reactAtomicMolecule.getDisplayName)(children) ? true : false;
  }, [children]);
  var nextContainer;
  var nextProps;
  var allProps = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, others), {}, {
    refCb: function refCb(el) {
      return el && (lastEl.current = el);
    },
    className: thisClassName,
    id: targetId
  });

  if (hasScrollReceiver) {
    nextContainer = children;
    nextProps = (0, _objectSpread2["default"])((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, children.props), allProps), {}, {
      targetId: targetId,
      container: container,
      noDelay: noDelay
    });
  } else {
    nextContainer = container || _reactAtomicMolecule.SemanticUI;
    nextProps = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, allProps), {}, {
      children: children
    });
  }

  return {
    nextContainer: nextContainer,
    nextProps: nextProps
  };
};

var ScrollSpy = function ScrollSpy(props) {
  var _useScrollSpy = useScrollSpy(props),
      nextContainer = _useScrollSpy.nextContainer,
      nextProps = _useScrollSpy.nextProps;

  return (0, _reactAtomicMolecule.build)(nextContainer)(nextProps);
};

var _default = ScrollSpy;
exports["default"] = _default;
module.exports = exports.default;