import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import _defineProperty from "reshow-runtime/es/helpers/defineProperty";
import { mergeMap, Set, Map, ImmutableStore } from "reshow-flux";
import getScrollInfo from "get-scroll-info";
import { isOnScreen } from "get-window-offset";
import getOffset from "getoffset";
import get, { toJS } from "get-object-value";
import { KEYS } from "reshow-constant";
import callfunc, { debounce } from "call-func";
import { win } from "win-doc";
import testForPassiveScroll from "../testForPassiveScroll";
var incNum = 0;
var DEFAULT_SCROLL_ID = -1;

var Scroller = /*#__PURE__*/function () {
  function Scroller() {
    _defineProperty(this, "storeName", "delayScroll");

    _defineProperty(this, "isInitEvent", {});

    _defineProperty(this, "isInitResizeEvent", false);

    _defineProperty(this, "spys", {});
  }

  var _proto = Scroller.prototype;

  _proto.initResizeEvent = function initResizeEvent() {
    var oWin = win();

    if (!oWin.__null) {
      this.isInitResizeEvent = true;

      if (oWin.addEventListener) {
        oWin.addEventListener("resize", this.bindHandleResize);
      } else {
        oWin.attachEvent("onresize", this.bindHandleResize);
      }
    }
  };

  _proto.initEvent = function initEvent(el) {
    var _this = this;

    if ("undefined" !== typeof el) {
      if (el.addEventListener) {
        var supportsPassive = testForPassiveScroll();
        el.addEventListener("scroll", this.scrollMonitor, supportsPassive ? {
          passive: true
        } : false);
      } else {
        el.attachEvent("onscroll", this.scrollMonitor);
      }

      setTimeout(function () {
        _this.trigger(el); //for lazy content


        setTimeout(function () {
          return _this.trigger(el);
        }, 777);
      });

      if (!this.isInitResizeEvent) {
        this.initResizeEvent();
      }
    }
  };

  _proto.removeEvent = function removeEvent(el) {
    if (el !== null && el !== void 0 && el.removeEventListener) {
      el.removeEventListener("scroll", this.scrollMonitor);
    } else {
      el === null || el === void 0 ? void 0 : el.deachEvent("onscroll", this.scrollMonitor);
    }
  };

  _proto.handleResize = function handleResize() {
    var _this2 = this;

    KEYS(this.spys).forEach(function (scrollId) {
      return _this2.scrollMonitor({
        target: {
          id: scrollId
        }
      });
    });
  };

  _proto.runScrollMonitor = function runScrollMonitor(e) {
    var delay = this.store.getState().get("scrollDelay");
    this.scrollDebounce({
      delay: delay,
      args: [e === null || e === void 0 ? void 0 : e.target]
    });
  };

  _proto.triggerScroll = function triggerScroll(scrollNode) {
    var _this3 = this;

    var scrollId = get(scrollNode, ["id"]) || DEFAULT_SCROLL_ID;
    var defaultMargin = this.store.getState().get("scrollMargin");
    var actives = {
      mdefault: null
    };
    var offsetCache = {};
    var arrMonitorScroll = [];
    var scroll = getScrollInfo();
    var scrollTop = scroll.top + defaultMargin;
    var margin;
    (this.spys[scrollId] || []).forEach(function (node) {
      var nodeEl = node.getOffsetEl();

      if (!nodeEl) {
        return;
      }

      var nodeId = _this3.getNodeId(node);

      var monitorScroll = callfunc(node.getMonitorScroll);
      var scrollMargin = callfunc(node.getScrollMargin);
      var pos = getOffset(nodeEl);

      if (monitorScroll) {
        if (scrollTop >= pos.top && scrollTop < pos.bottom) {
          actives.mdefault = nodeId;
        }

        arrMonitorScroll.push(node);
      }

      margin = scrollMargin ? scrollMargin : defaultMargin;
      pos = isOnScreen(pos, scroll, margin);
      offsetCache[nodeId] = pos;
    });
    var allMonitorNodeLen = arrMonitorScroll.length;
    this.margins.forEach(function (margin) {
      scrollTop = scroll.top + margin;
      actives["m" + margin] = null;
      var i = allMonitorNodeLen;

      while (i--) {
        var node = arrMonitorScroll[i];

        var nodeId = _this3.getNodeId(node);

        var pos = offsetCache[nodeId];

        if (scrollTop >= pos.top && scrollTop <= pos.bottom - 1) {
          actives["m" + margin] = nodeId;
          break;
        }
      }
    });
    this.margins = this.margins.clear();
    this.dispatch(_objectSpread(_objectSpread({}, actives), {}, {
      nodes: offsetCache,
      scroll: scroll,
      storeName: this.storeName
    }));
  };

  _proto.getNode = function getNode(id) {
    if (this.arrMap && this.arrMap.get) {
      return toJS(this.arrMap.get(id));
    }
  };

  _proto.getOffset = function getOffset(id, callName) {
    var nodes = this.store.getMap("nodes");
    return nodes[id];
  };

  _proto.hasAttach = function hasAttach(node) {
    var attachToId = this.getAttachToId(node);

    if (this.spys[attachToId] && this.spys[attachToId].has(node)) {
      return attachToId;
    } else {
      return false;
    }
  };

  _proto.getNodeId = function getNodeId(node) {
    var id = callfunc(node.getId) || node.id;

    if (!id) {
      return this.setNodeId(node);
    } else {
      return id;
    }
  };

  _proto.setNodeId = function setNodeId(node) {
    var nextId = "spy-" + incNum;
    incNum++;

    if (node.setId) {
      node.setId(nextId);
    } else {
      node.id = nextId;
    }

    return nextId;
  };

  _proto.getAttachToId = function getAttachToId(node) {
    var attachTo = callfunc(node.getAttachTo);
    var attachToId;

    if (attachTo) {
      attachToId = this.getNodeId(attachTo);
    } else {
      var oWin = win();

      if (!oWin.__null) {
        node.setAttachTo(oWin);
      }

      attachToId = DEFAULT_SCROLL_ID;
    }

    return attachToId;
  };

  _proto.attach = function attach(node) {
    var nodeId = this.getNodeId(node);
    var attachToId = this.getAttachToId(node);

    if (!this.spys[attachToId]) {
      this.spys[attachToId] = Set().add(node);
    } else {
      this.spys[attachToId] = this.spys[attachToId].add(node);
    }

    this.arrNode = this.arrNode.set(nodeId, node);

    if (!this.isInitEvent[attachToId]) {
      this.isInitEvent[attachToId] = true;
      this.initEvent(callfunc(node.getAttachTo));
    }

    return nodeId;
  };

  _proto.detach = function detach(node) {
    var attachToId = this.hasAttach(node);

    if (attachToId) {
      this.spys[attachToId] = this.spys[attachToId].remove(node);
      this.arrNode = this.arrNode["delete"](this.getNodeId(node));

      if (!this.spys[attachToId].size) {
        this.removeEvent(node.attachTo);
        delete this.spys[attachToId];
        this.isInitEvent[attachToId] = false;
      }
    }
  };

  _proto.addMargin = function addMargin(num) {
    this.margins = this.margins.add(num);
  };

  _proto.deleteMargin = function deleteMargin(num) {
    this.margins = this.margins.remove(num);
  };

  _proto.getInitialState = function getInitialState() {
    this.trigger = this.triggerScroll.bind(this);
    this.arrNode = Map();
    this.margins = Set();
    this.scrollMonitor = this.runScrollMonitor.bind(this);
    this.scrollDebounce = debounce(this.trigger);
    this.bindHandleResize = this.handleResize.bind(this);
    return Map({
      scrollDelay: 50,
      scrollMargin: 0
    });
  };

  _proto.reduce = function reduce(state, action) {
    return mergeMap(state, action);
  };

  return Scroller;
}();

var oDelayScroller = new Scroller();

var _ImmutableStore = ImmutableStore(oDelayScroller.reduce.bind(oDelayScroller), oDelayScroller.getInitialState.bind(oDelayScroller)),
    store = _ImmutableStore[0],
    delayScrollDispatch = _ImmutableStore[1];

store.scroller = oDelayScroller;
oDelayScroller.dispatch = delayScrollDispatch;
oDelayScroller.store = store;
export default store;
export { Scroller };